{"version":3,"sources":["../node_modules/@codemirror/stream-parser/dist/index.js"],"names":["countCol","string","end","tabSize","startIndex","arguments","length","undefined","startValue","search","n","i","charCodeAt","StringStream","indentUnit","this","pos","start","lastColumnPos","lastColumnValue","key","value","charAt","match","ch","RegExp","test","eat","found","indexOf","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","slice","index","defaultCopyState","state","newState","prop","val","Array","StreamLanguage","_Language","parser","_this","self","spec","data","languageData","p","token","blankLine","startState","copyState","indent","impl","_Parser","_class","apply","input","fragments","ranges","Parse","call","type","define","id","typeArray","name","props","add","push","docID","of","cx","getIndent","streamParser","stateAfter","perNode","tree","at","resolve","topNode","parent","statePos","findState","from","unit","line","doc","lineAt","Math","min","to","stream","text","readToken","exec","get","lang","off","startPos","before","children","child","positions","cutTree","inside","inner","concat","stoppedAt","chunks","chunkPos","chunk","chunkReused","rangeIndex","context","_findStartInFragments","editorState","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","f","offset","err","return","empty","findStartInFragments","parsedPos","chunkStart","viewport","skipUntilInView","parseEnd","parseLine","finishChunk","finish","lineChunks","eol","lineAfter","rangeEnd","rangeStart","after","side","offPos","size","skipGapsTo","len0","_this$nextLine","nextLine","emitToken","tokenID","build","buffer","nodeSet","topID","maxBufferLength","reused","balance","result","Error","tokenTable","Object","create","none","warned","tag","tagStr","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","split","part","warnForPart","replace","createTokenType","_i","_arr","_ref3","_ref2","legacyName","msg","console","warn"],"mappings":"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","file":"static/js/107.9160d1df.chunk.js","sourcesContent":["import _defineProperty from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _possibleConstructorReturn from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Parser, NodeProp, Tree, NodeType, NodeSet } from '@lezer/common';\nimport { tags, styleTags } from '@codemirror/highlight';\nimport { Language, defineLanguageFacet, indentService, syntaxTree, ParseContext, getIndentUnit, languageDataProp } from '@codemirror/language'; // Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\n\nfunction countCol(string, end, tabSize) {\n  var startIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var startValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n\n  var n = startValue;\n\n  for (var i = startIndex; i < end; i++) {\n    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;\n  }\n\n  return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\n\n\nvar StringStream =\n/*#__PURE__*/\nfunction () {\n  /**\n  @internal\n  */\n  function StringStream(\n  /**\n  The line.\n  */\n  string, tabSize,\n  /**\n  The current indent unit size.\n  */\n  indentUnit) {\n    _classCallCheck(this, StringStream);\n\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    /**\n    The current position on the line.\n    */\n\n    this.pos = 0;\n    /**\n    The start position of the current token.\n    */\n\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  /**\n  True if we are at the end of the line.\n  */\n\n\n  _createClass(StringStream, [{\n    key: \"eol\",\n    value: function eol() {\n      return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */\n\n  }, {\n    key: \"sol\",\n    value: function sol() {\n      return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n\n  }, {\n    key: \"eat\",\n    value: function eat(match) {\n      var ch = this.string.charAt(this.pos);\n      var ok;\n      if (typeof match == \"string\") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n\n  }, {\n    key: \"eatWhile\",\n    value: function eatWhile(match) {\n      var start = this.pos;\n\n      while (this.eat(match)) {}\n\n      return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n\n  }, {\n    key: \"eatSpace\",\n    value: function eatSpace() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n        ++this.pos;\n      }\n\n      return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n\n  }, {\n    key: \"skipToEnd\",\n    value: function skipToEnd() {\n      this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n\n  }, {\n    key: \"skipTo\",\n    value: function skipTo(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    }\n    /**\n    Move back `n` characters.\n    */\n\n  }, {\n    key: \"backUp\",\n    value: function backUp(n) {\n      this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */\n\n  }, {\n    key: \"column\",\n    value: function column() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n\n      return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n\n  }, {\n    key: \"indentation\",\n    value: function indentation() {\n      return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n\n  }, {\n    key: \"match\",\n    value: function match(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function cased(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n\n        var substr = this.string.substr(this.pos, pattern.length);\n\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        } else return null;\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    }\n    /**\n    Get the current token.\n    */\n\n  }, {\n    key: \"current\",\n    value: function current() {\n      return this.string.slice(this.start, this.pos);\n    }\n  }]);\n\n  return StringStream;\n}();\n\nfunction fullParser(spec) {\n  return {\n    token: spec.token,\n    blankLine: spec.blankLine || function () {},\n    startState: spec.startState || function () {\n      return true;\n    },\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || function () {\n      return null;\n    },\n    languageData: spec.languageData || {}\n  };\n}\n\nfunction defaultCopyState(state) {\n  if (typeof state != \"object\") return state;\n  var newState = {};\n\n  for (var prop in state) {\n    var val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n\n  return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\n\n\nvar StreamLanguage =\n/*#__PURE__*/\nfunction (_Language) {\n  _inherits(StreamLanguage, _Language);\n\n  function StreamLanguage(parser) {\n    var _this;\n\n    _classCallCheck(this, StreamLanguage);\n\n    var data = defineLanguageFacet(parser.languageData);\n    var p = fullParser(parser),\n        self;\n    var impl = new (\n    /*#__PURE__*/\n    function (_Parser) {\n      _inherits(_class, _Parser);\n\n      function _class() {\n        _classCallCheck(this, _class);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));\n      }\n\n      _createClass(_class, [{\n        key: \"createParse\",\n        value: function createParse(input, fragments, ranges) {\n          return new Parse(self, input, fragments, ranges);\n        }\n      }]);\n\n      return _class;\n    }(Parser))();\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StreamLanguage).call(this, data, impl, docID(data), [indentService.of(function (cx, pos) {\n      return _this.getIndent(cx, pos);\n    })]));\n    self = _assertThisInitialized(_this);\n    _this.streamParser = p;\n    _this.stateAfter = new NodeProp({\n      perNode: true\n    });\n    return _this;\n  }\n\n  _createClass(StreamLanguage, [{\n    key: \"getIndent\",\n    value: function getIndent(cx, pos) {\n      var tree = syntaxTree(cx.state),\n          at = tree.resolve(pos);\n\n      while (at && at.type != this.topNode) {\n        at = at.parent;\n      }\n\n      if (!at) return null;\n      var start = findState(this, tree, 0, at.from, pos),\n          statePos,\n          state;\n\n      if (start) {\n        state = start.state;\n        statePos = start.pos + 1;\n      } else {\n        state = this.streamParser.startState(cx.unit);\n        statePos = 0;\n      }\n\n      if (pos - statePos > 10000\n      /* MaxIndentScanDist */\n      ) return null;\n\n      while (statePos < pos) {\n        var line = cx.state.doc.lineAt(statePos),\n            end = Math.min(pos, line.to);\n\n        if (line.length) {\n          var stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n\n          while (stream.pos < end - line.from) {\n            readToken(this.streamParser.token, stream, state);\n          }\n        } else {\n          this.streamParser.blankLine(state, cx.unit);\n        }\n\n        if (end == pos) break;\n        statePos = line.to + 1;\n      }\n\n      var _cx$state$doc$lineAt = cx.state.doc.lineAt(pos),\n          text = _cx$state$doc$lineAt.text;\n\n      return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n  }, {\n    key: \"allowsNesting\",\n    get: function get() {\n      return false;\n    }\n  }], [{\n    key: \"define\",\n    value: function define(spec) {\n      return new StreamLanguage(spec);\n    }\n  }]);\n\n  return StreamLanguage;\n}(Language);\n\nfunction findState(lang, tree, off, startPos, before) {\n  var state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    var child = tree.children[i],\n        pos = off + tree.positions[i];\n    var found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n\n  return null;\n}\n\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    var pos = tree.positions[i] + from,\n        child = tree.children[i],\n        inner = void 0;\n\n    if (pos < to && child instanceof Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n\n  return null;\n}\n\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var f = _step.value;\n      var found = f.from <= startPos && f.to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, f.to),\n          tree = void 0;\n      if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n        state: found.state,\n        tree: tree\n      };\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n    tree: Tree.empty\n  };\n}\n\nvar Parse =\n/*#__PURE__*/\nfunction () {\n  function Parse(lang, input, fragments, ranges) {\n    _classCallCheck(this, Parse);\n\n    this.lang = lang;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.stoppedAt = null;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.rangeIndex = 0;\n    this.to = ranges[ranges.length - 1].to;\n    var context = ParseContext.get(),\n        from = ranges[0].from;\n\n    var _findStartInFragments = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state),\n        state = _findStartInFragments.state,\n        tree = _findStartInFragments.tree;\n\n    this.state = state;\n    this.parsedPos = this.chunkStart = from + tree.length;\n\n    if (tree.length) {\n      this.chunks.push(tree);\n      this.chunkPos.push(0);\n    }\n\n    if (context && this.parsedPos < context.viewport.from - 100000\n    /* MaxDistanceBeforeViewport */\n    ) {\n        this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n        context.skipUntilInView(this.parsedPos, context.viewport.from);\n        this.parsedPos = context.viewport.from;\n      }\n  }\n\n  _createClass(Parse, [{\n    key: \"advance\",\n    value: function advance() {\n      var context = ParseContext.get();\n      var parseEnd = this.stoppedAt == null ? this.to : this.stoppedAt;\n      var end = Math.min(parseEnd, this.chunkStart + 2048\n      /* ChunkSize */\n      );\n      if (context) end = Math.min(end, context.viewport.to);\n\n      while (this.parsedPos < end) {\n        this.parseLine(context);\n      }\n\n      if (this.chunkStart < this.parsedPos) this.finishChunk();\n      if (this.parsedPos >= parseEnd) return this.finish();\n\n      if (context && this.parsedPos > context.viewport.to) {\n        context.skipUntilInView(this.parsedPos, parseEnd);\n        return this.finish();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"stopAt\",\n    value: function stopAt(pos) {\n      this.stoppedAt = pos;\n    }\n  }, {\n    key: \"lineAfter\",\n    value: function lineAfter(pos) {\n      var chunk = this.input.chunk(pos);\n\n      if (!this.input.lineChunks) {\n        var eol = chunk.indexOf(\"\\n\");\n        if (eol > -1) chunk = chunk.slice(0, eol);\n      } else if (chunk == \"\\n\") {\n        chunk = \"\";\n      }\n\n      return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      var from = this.parsedPos,\n          line = this.lineAfter(from),\n          end = from + line.length;\n\n      for (var index = this.rangeIndex;;) {\n        var rangeEnd = this.ranges[index].to;\n        if (rangeEnd >= end) break;\n        line = line.slice(0, rangeEnd - (end - line.length));\n        index++;\n        if (index == this.ranges.length) break;\n        var rangeStart = this.ranges[index].from;\n        var after = this.lineAfter(rangeStart);\n        line += after;\n        end = rangeStart + after.length;\n      }\n\n      return {\n        line: line,\n        end: end\n      };\n    }\n  }, {\n    key: \"skipGapsTo\",\n    value: function skipGapsTo(pos, offset, side) {\n      for (;;) {\n        var end = this.ranges[this.rangeIndex].to,\n            offPos = pos + offset;\n        if (side > 0 ? end > offPos : end >= offPos) break;\n        var start = this.ranges[++this.rangeIndex].from;\n        offset += start - end;\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"emitToken\",\n    value: function emitToken(id, from, to, size, offset) {\n      if (this.ranges.length > 1) {\n        offset = this.skipGapsTo(from, offset, 1);\n        from += offset;\n        var len0 = this.chunk.length;\n        offset = this.skipGapsTo(to, offset, -1);\n        to += offset;\n        size += this.chunk.length - len0;\n      }\n\n      this.chunk.push(id, from, to, size);\n      return offset;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(context) {\n      var _this$nextLine = this.nextLine(),\n          line = _this$nextLine.line,\n          end = _this$nextLine.end,\n          offset = 0,\n          streamParser = this.lang.streamParser;\n\n      var stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n\n      if (stream.eol()) {\n        streamParser.blankLine(this.state, stream.indentUnit);\n      } else {\n        while (!stream.eol()) {\n          var token = readToken(streamParser.token, stream, this.state);\n          if (token) offset = this.emitToken(tokenID(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n        }\n      }\n\n      this.parsedPos = end;\n      if (this.parsedPos < this.to) this.parsedPos++;\n    }\n  }, {\n    key: \"finishChunk\",\n    value: function finishChunk() {\n      var tree = Tree.build({\n        buffer: this.chunk,\n        start: this.chunkStart,\n        length: this.parsedPos - this.chunkStart,\n        nodeSet: nodeSet,\n        topID: 0,\n        maxBufferLength: 2048\n        /* ChunkSize */\n        ,\n        reused: this.chunkReused\n      });\n      tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n      this.chunks.push(tree);\n      this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n      this.chunk = [];\n      this.chunkReused = undefined;\n      this.chunkStart = this.parsedPos;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n  }]);\n\n  return Parse;\n}();\n\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n\n  for (var i = 0; i < 10; i++) {\n    var result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\n\nvar tokenTable =\n/*@__PURE__*/\nObject.create(null);\nvar typeArray = [NodeType.none];\nvar nodeSet =\n/*@__PURE__*/\nnew NodeSet(typeArray);\nvar warned = [];\n\nfunction tokenID(tag) {\n  return !tag ? 0 : tokenTable[tag] || (tokenTable[tag] = createTokenType(tag));\n}\n\nfor (var _i = 0, _arr = [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"typeName\"], [\"attribute\", \"propertyName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]; _i < _arr.length; _i++) {\n  var _ref3 = _arr[_i];\n\n  var _ref2 = _slicedToArray(_ref3, 2);\n\n  var legacyName = _ref2[0];\n  var name = _ref2[1];\n  tokenTable[legacyName] =\n  /*@__PURE__*/\n  tokenID(name);\n}\n\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\n\nfunction createTokenType(tagStr) {\n  var tag = null;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = tagStr.split(\".\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var part = _step2.value;\n      var value = tags[part];\n\n      if (!value) {\n        warnForPart(part, \"Unknown highlighting tag \".concat(part));\n      } else if (typeof value == \"function\") {\n        if (!tag) warnForPart(part, \"Modifier \".concat(part, \" used at start of tag\"));else tag = value(tag);\n      } else {\n        if (tag) warnForPart(part, \"Tag \".concat(part, \" used as modifier\"));else tag = value;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  if (!tag) return 0;\n  var name = tagStr.replace(/ /g, \"_\"),\n      type = NodeType.define({\n    id: typeArray.length,\n    name: name,\n    props: [styleTags(_defineProperty({}, name, tag))]\n  });\n  typeArray.push(type);\n  return type.id;\n}\n\nfunction docID(data) {\n  var type = NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [languageDataProp.add(function () {\n      return data;\n    })]\n  });\n  typeArray.push(type);\n  return type;\n}\n\nexport { StreamLanguage, StringStream };"],"sourceRoot":""}