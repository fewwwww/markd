{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/haskell.js"],"names":["switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","eat","t","ncomment","type","nest","currNest","eol","stringLiteral","match","skipToEnd","stringGap","wellKnownWords","wkw","setType","i","arguments","length","haskell","startState","copyState","s","token","stream","state","w","current","hasOwnProperty","languageData","commentTokens","line","block","open","close"],"mappings":"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","file":"static/js/51.4c5cdbbc.chunk.js","sourcesContent":["function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n} // These should all be Unicode extended, as per the Haskell 2010 report\n\n\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n\n      return switchState(source, setState, ncomment(t, 1));\n    }\n\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next(); // should handle other escapes here\n    } else {\n      source.next();\n    }\n\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n\n        return \"integer\";\n      }\n\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n\n        return \"number\";\n      }\n    }\n\n    source.eatWhile(digitRE);\n    var t = \"number\";\n\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\")) return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n\n    source.eatWhile(symbolRE);\n    return \"variable\";\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n\n  return function (source, setState) {\n    var currNest = nest;\n\n    while (!source.eol()) {\n      var ch = source.next();\n\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      } else if (ch == '-' && source.eat('}')) {\n        --currNest;\n\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n\n      if (source.eat('&')) {} else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\nvar wellKnownWords = function () {\n  var wkw = {};\n\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++) {\n        wkw[arguments[i]] = t;\n      }\n    };\n  }\n\n  setType(\"keyword\")(\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\", \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n  setType(\"keyword\")(\"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n  setType(\"builtin\")(\"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\", \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"*>\", \"**\");\n  setType(\"builtin\")(\"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\", \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\", \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\", \"String\", \"True\");\n  setType(\"builtin\")(\"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\", \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\", \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\", \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\", \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\", \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\", \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\", \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\", \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\", \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\", \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\", \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\", \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\", \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\", \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\", \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\", \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\", \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\", \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\", \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\", \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\", \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\", \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\", \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\", \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\", \"zip3\", \"zipWith\", \"zipWith3\");\n  return wkw;\n}();\n\nexport var haskell = {\n  startState: function startState() {\n    return {\n      f: normal\n    };\n  },\n  copyState: function copyState(s) {\n    return {\n      f: s.f\n    };\n  },\n  token: function token(stream, state) {\n    var t = state.f(stream, function (s) {\n      state.f = s;\n    });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"--\",\n      block: {\n        open: \"{-\",\n        close: \"-}\"\n      }\n    }\n  }\n};"],"sourceRoot":""}