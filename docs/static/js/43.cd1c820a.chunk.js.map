{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/erlang.js"],"names":["typeWords","keywordWords","separatorRE","separatorWords","operatorAtomWords","operatorSymbolRE","operatorSymbolWords","openParenRE","openParenWords","closeParenRE","closeParenWords","guardWords","bifWords","anumRE","escapesRE","nongreedy","stream","re","words","current","length","test","backUp","peek","next","is_member","greedy","doubleQuote","quote","singleQuote","quoteChar","escapeChar","eol","ch","element","list","indexOf","rval","state","type","token","tokenStack","s","last","pop","push","maybe_drop_pre","slice","d","g","i","e","r","m","E","maybe_drop_post","pushToken","aToken","column","indentation","realToken","tok","col","ind","typ","indent","fakeToken","peekToken","depth","len","dep","stack","tt","tokens","ss","concat","getToken","objs","getTokenIndex","truthy","propname","propvals","x","erlang","startState","in_string","in_atom","eatSpace","match","skipToEnd","eatWhile","w","lookahead","digitRE","eat","textAfter","cx","t","wordAfter","str","index","wordafter","currT","prevT","unit","postcommaToken","stop","oper","defaultToken","languageData","commentTokens","line"],"mappings":"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","file":"static/js/43.cd1c820a.chunk.js","sourcesContent":["/////////////////////////////////////////////////////////////////////////////\n// constants\nvar typeWords = [\"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\nvar keywordWords = [\"after\", \"begin\", \"catch\", \"case\", \"cond\", \"end\", \"fun\", \"if\", \"let\", \"of\", \"query\", \"receive\", \"try\", \"when\"];\nvar separatorRE = /[\\->,;]/;\nvar separatorWords = [\"->\", \";\", \",\"];\nvar operatorAtomWords = [\"and\", \"andalso\", \"band\", \"bnot\", \"bor\", \"bsl\", \"bsr\", \"bxor\", \"div\", \"not\", \"or\", \"orelse\", \"rem\", \"xor\"];\nvar operatorSymbolRE = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\"=\", \"+\", \"-\", \"*\", \"/\", \">\", \">=\", \"<\", \"=<\", \"=:=\", \"==\", \"=/=\", \"/=\", \"||\", \"<-\", \"!\"];\nvar openParenRE = /[<\\(\\[\\{]/;\nvar openParenWords = [\"<<\", \"(\", \"[\", \"{\"];\nvar closeParenRE = /[>\\)\\]\\}]/;\nvar closeParenWords = [\"}\", \"]\", \")\", \">>\"];\nvar guardWords = [\"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_record\", \"is_reference\", \"is_tuple\", \"atom\", \"binary\", \"bitstring\", \"boolean\", \"function\", \"integer\", \"list\", \"number\", \"pid\", \"port\", \"record\", \"reference\", \"tuple\"];\nvar bifWords = [\"abs\", \"adler32\", \"adler32_combine\", \"alive\", \"apply\", \"atom_to_binary\", \"atom_to_list\", \"binary_to_atom\", \"binary_to_existing_atom\", \"binary_to_list\", \"binary_to_term\", \"bit_size\", \"bitstring_to_list\", \"byte_size\", \"check_process_code\", \"contact_binary\", \"crc32\", \"crc32_combine\", \"date\", \"decode_packet\", \"delete_module\", \"disconnect_node\", \"element\", \"erase\", \"exit\", \"float\", \"float_to_list\", \"garbage_collect\", \"get\", \"get_keys\", \"group_leader\", \"halt\", \"hd\", \"integer_to_list\", \"internal_bif\", \"iolist_size\", \"iolist_to_binary\", \"is_alive\", \"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_process_alive\", \"is_record\", \"is_reference\", \"is_tuple\", \"length\", \"link\", \"list_to_atom\", \"list_to_binary\", \"list_to_bitstring\", \"list_to_existing_atom\", \"list_to_float\", \"list_to_integer\", \"list_to_pid\", \"list_to_tuple\", \"load_module\", \"make_ref\", \"module_loaded\", \"monitor_node\", \"node\", \"node_link\", \"node_unlink\", \"nodes\", \"notalive\", \"now\", \"open_port\", \"pid_to_list\", \"port_close\", \"port_command\", \"port_connect\", \"port_control\", \"pre_loaded\", \"process_flag\", \"process_info\", \"processes\", \"purge_module\", \"put\", \"register\", \"registered\", \"round\", \"self\", \"setelement\", \"size\", \"spawn\", \"spawn_link\", \"spawn_monitor\", \"spawn_opt\", \"split_binary\", \"statistics\", \"term_to_binary\", \"time\", \"throw\", \"tl\", \"trunc\", \"tuple_size\", \"tuple_to_list\", \"unlink\", \"unregister\", \"whereis\"]; // upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\n\nvar anumRE = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE = /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/; /////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream, state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  } // in multi-line atom\n\n\n  if (state.in_atom) {\n    state.in_atom = !singleQuote(stream);\n    return rval(state, stream, \"atom\");\n  } // whitespace\n\n\n  if (stream.eatSpace()) {\n    return rval(state, stream, \"whitespace\");\n  } // attributes and type specs\n\n\n  if (!peekToken(state) && stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(), typeWords)) {\n      return rval(state, stream, \"type\");\n    } else {\n      return rval(state, stream, \"attribute\");\n    }\n  }\n\n  var ch = stream.next(); // comment\n\n  if (ch == '%') {\n    stream.skipToEnd();\n    return rval(state, stream, \"comment\");\n  } // colon\n\n\n  if (ch == \":\") {\n    return rval(state, stream, \"colon\");\n  } // macro\n\n\n  if (ch == '?') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"macro\");\n  } // record\n\n\n  if (ch == \"#\") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"record\");\n  } // dollar escape\n\n\n  if (ch == \"$\") {\n    if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n      return rval(state, stream, \"error\");\n    }\n\n    return rval(state, stream, \"number\");\n  } // dot\n\n\n  if (ch == \".\") {\n    return rval(state, stream, \"dot\");\n  } // quoted atom\n\n\n  if (ch == '\\'') {\n    if (!(state.in_atom = !singleQuote(stream))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/, true);\n        return rval(state, stream, \"fun\"); // 'f'/0 style fun\n      }\n\n      if (stream.match(/\\s*\\(/, false) || stream.match(/\\s*:/, false)) {\n        return rval(state, stream, \"function\");\n      }\n    }\n\n    return rval(state, stream, \"atom\");\n  } // string\n\n\n  if (ch == '\"') {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  } // variable\n\n\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"variable\");\n  } // atom/keyword/BIF/function\n\n\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n\n    if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/, true);\n      return rval(state, stream, \"fun\"); // f/0 style fun\n    }\n\n    var w = stream.current();\n\n    if (is_member(w, keywordWords)) {\n      return rval(state, stream, \"keyword\");\n    } else if (is_member(w, operatorAtomWords)) {\n      return rval(state, stream, \"operator\");\n    } else if (stream.match(/\\s*\\(/, false)) {\n      // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n      if (is_member(w, bifWords) && (peekToken(state).token != \":\" || peekToken(state, 2).token == \"erlang\")) {\n        return rval(state, stream, \"builtin\");\n      } else if (is_member(w, guardWords)) {\n        return rval(state, stream, \"guard\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (lookahead(stream) == \":\") {\n      if (w == \"erlang\") {\n        return rval(state, stream, \"builtin\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (is_member(w, [\"true\", \"false\"])) {\n      return rval(state, stream, \"boolean\");\n    } else {\n      return rval(state, stream, \"atom\");\n    }\n  } // number\n\n\n  var digitRE = /[0-9]/;\n  var radixRE = /[0-9a-zA-Z]/; // 36#zZ style int\n\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n\n    if (stream.eat('#')) {\n      // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1); //\"36#\" - syntax error\n      }\n    } else if (stream.eat('.')) {\n      // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1); // \"3.\" - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {\n          // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2); // \"2e-\" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1); // \"2e\" - syntax error\n            }\n          }\n        }\n      }\n    }\n\n    return rval(state, stream, \"number\"); // normal integer\n  } // open parens\n\n\n  if (nongreedy(stream, openParenRE, openParenWords)) {\n    return rval(state, stream, \"open_paren\");\n  } // close parens\n\n\n  if (nongreedy(stream, closeParenRE, closeParenWords)) {\n    return rval(state, stream, \"close_paren\");\n  } // separators\n\n\n  if (greedy(stream, separatorRE, separatorWords)) {\n    return rval(state, stream, \"separator\");\n  } // operators\n\n\n  if (greedy(stream, operatorSymbolRE, operatorSymbolWords)) {\n    return rval(state, stream, \"operator\");\n  }\n\n  return rval(state, stream, null);\n} /////////////////////////////////////////////////////////////////////////////\n// utilities\n\n\nfunction nongreedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n\n    while (re.test(stream.peek())) {\n      stream.next();\n\n      if (is_member(stream.current(), words)) {\n        return true;\n      }\n    }\n\n    stream.backUp(stream.current().length - 1);\n  }\n\n  return false;\n}\n\nfunction greedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(), words)) {\n        return true;\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n    stream.next();\n  }\n\n  return false;\n}\n\nfunction doubleQuote(stream) {\n  return quote(stream, '\"', '\\\\');\n}\n\nfunction singleQuote(stream) {\n  return quote(stream, '\\'', '\\\\');\n}\n\nfunction quote(stream, quoteChar, escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n\n    if (ch == quoteChar) {\n      return true;\n    } else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n\n  return false;\n}\n\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false);\n  return m ? m[1] : \"\";\n}\n\nfunction is_member(element, list) {\n  return -1 < list.indexOf(element);\n}\n\nfunction rval(state, stream, type) {\n  // parse stack\n  pushToken(state, realToken(type, stream)); // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n\n  switch (type) {\n    case \"atom\":\n      return \"atom\";\n\n    case \"attribute\":\n      return \"attribute\";\n\n    case \"boolean\":\n      return \"atom\";\n\n    case \"builtin\":\n      return \"builtin\";\n\n    case \"close_paren\":\n      return null;\n\n    case \"colon\":\n      return null;\n\n    case \"comment\":\n      return \"comment\";\n\n    case \"dot\":\n      return null;\n\n    case \"error\":\n      return \"error\";\n\n    case \"fun\":\n      return \"meta\";\n\n    case \"function\":\n      return \"tag\";\n\n    case \"guard\":\n      return \"property\";\n\n    case \"keyword\":\n      return \"keyword\";\n\n    case \"macro\":\n      return \"macroName\";\n\n    case \"number\":\n      return \"number\";\n\n    case \"open_paren\":\n      return null;\n\n    case \"operator\":\n      return \"operator\";\n\n    case \"record\":\n      return \"bracket\";\n\n    case \"separator\":\n      return null;\n\n    case \"string\":\n      return \"string\";\n\n    case \"type\":\n      return \"def\";\n\n    case \"variable\":\n      return \"variable\";\n\n    default:\n      return null;\n  }\n}\n\nfunction aToken(tok, col, ind, typ) {\n  return {\n    token: tok,\n    column: col,\n    indent: ind,\n    type: typ\n  };\n}\n\nfunction realToken(type, stream) {\n  return aToken(stream.current(), stream.column(), stream.indentation(), type);\n}\n\nfunction fakeToken(type) {\n  return aToken(type, 0, 0, type);\n}\n\nfunction peekToken(state, depth) {\n  var len = state.tokenStack.length;\n  var dep = depth ? depth : 1;\n\n  if (len < dep) {\n    return false;\n  } else {\n    return state.tokenStack[len - dep];\n  }\n}\n\nfunction pushToken(state, token) {\n  if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack, token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\n\nfunction maybe_drop_pre(s, token) {\n  var last = s.length - 1;\n\n  if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n    s.pop();\n  } else if (0 < last && s[last].type === \"group\") {\n    s.pop();\n    s.push(token);\n  } else {\n    s.push(token);\n  }\n\n  return s;\n}\n\nfunction maybe_drop_post(s) {\n  if (!s.length) return s;\n  var last = s.length - 1;\n\n  if (s[last].type === \"dot\") {\n    return [];\n  }\n\n  if (last > 1 && s[last].type === \"fun\" && s[last - 1].token === \"fun\") {\n    return s.slice(0, last - 1);\n  }\n\n  switch (s[last].token) {\n    case \"}\":\n      return d(s, {\n        g: [\"{\"]\n      });\n\n    case \"]\":\n      return d(s, {\n        i: [\"[\"]\n      });\n\n    case \")\":\n      return d(s, {\n        i: [\"(\"]\n      });\n\n    case \">>\":\n      return d(s, {\n        i: [\"<<\"]\n      });\n\n    case \"end\":\n      return d(s, {\n        i: [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]\n      });\n\n    case \",\":\n      return d(s, {\n        e: [\"begin\", \"try\", \"when\", \"->\", \",\", \"(\", \"[\", \"{\", \"<<\"]\n      });\n\n    case \"->\":\n      return d(s, {\n        r: [\"when\"],\n        m: [\"try\", \"if\", \"case\", \"receive\"]\n      });\n\n    case \";\":\n      return d(s, {\n        E: [\"case\", \"fun\", \"if\", \"receive\", \"try\", \"when\"]\n      });\n\n    case \"catch\":\n      return d(s, {\n        e: [\"try\"]\n      });\n\n    case \"of\":\n      return d(s, {\n        e: [\"case\"]\n      });\n\n    case \"after\":\n      return d(s, {\n        e: [\"receive\", \"try\"]\n      });\n\n    default:\n      return s;\n  }\n}\n\nfunction d(stack, tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see \"E\" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is \"m\", that is all it does.\n  // If type is \"i\", it will also remove the matched Token and the top Token.\n  // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n  // If type is \"r\", it will remove the matched Token, but not the top Token.\n  // If type is \"e\", it will keep the matched Token but not the top Token.\n  // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n  //  in which case it will return an empty stack.\n  for (var type in tt) {\n    var len = stack.length - 1;\n    var tokens = tt[type];\n\n    for (var i = len - 1; -1 < i; i--) {\n      if (is_member(stack[i].token, tokens)) {\n        var ss = stack.slice(0, i);\n\n        switch (type) {\n          case \"m\":\n            return ss.concat(stack[i]).concat(stack[len]);\n\n          case \"r\":\n            return ss.concat(stack[len]);\n\n          case \"i\":\n            return ss;\n\n          case \"g\":\n            return ss.concat(fakeToken(\"group\"));\n\n          case \"E\":\n            return ss.concat(stack[i]);\n\n          case \"e\":\n            return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n\n  return type == \"E\" ? [] : stack;\n} /////////////////////////////////////////////////////////////////////////////\n// indenter\n\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state, 1);\n  var prevT = peekToken(state, 2);\n\n  if (state.in_string || state.in_atom) {\n    return null;\n  } else if (!prevT) {\n    return 0;\n  } else if (currT.token == \"when\") {\n    return currT.column + cx.unit;\n  } else if (wordAfter === \"when\" && prevT.type === \"function\") {\n    return prevT.indent + cx.unit;\n  } else if (wordAfter === \"(\" && currT.token === \"fun\") {\n    return currT.column + 3;\n  } else if (wordAfter === \"catch\" && (t = getToken(state, [\"try\"]))) {\n    return t.column;\n  } else if (is_member(wordAfter, [\"end\", \"after\", \"of\"])) {\n    t = getToken(state, [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]);\n    return t ? t.column : null;\n  } else if (is_member(wordAfter, closeParenWords)) {\n    t = getToken(state, openParenWords);\n    return t ? t.column : null;\n  } else if (is_member(currT.token, [\",\", \"|\", \"||\"]) || is_member(wordAfter, [\",\", \"|\", \"||\"])) {\n    t = postcommaToken(state);\n    return t ? t.column + t.token.length : cx.unit;\n  } else if (currT.token == \"->\") {\n    if (is_member(prevT.token, [\"receive\", \"case\", \"if\", \"try\"])) {\n      return prevT.column + cx.unit + cx.unit;\n    } else {\n      return prevT.column + cx.unit;\n    }\n  } else if (is_member(currT.token, openParenWords)) {\n    return currT.column + currT.token.length;\n  } else {\n    t = defaultToken(state);\n    return truthy(t) ? t.column + cx.unit : 0;\n  }\n}\n\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n  return truthy(m) && m.index === 0 ? m[0] : \"\";\n}\n\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0, -1);\n  var i = getTokenIndex(objs, \"type\", [\"open_paren\"]);\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs, \"type\", [\"open_paren\", \"separator\", \"keyword\"]);\n  var oper = getTokenIndex(objs, \"type\", [\"operator\"]);\n\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop + 1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\n\nfunction getToken(state, tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs, \"token\", tokens);\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction getTokenIndex(objs, propname, propvals) {\n  for (var i = objs.length - 1; -1 < i; i--) {\n    if (is_member(objs[i][propname], propvals)) {\n      return i;\n    }\n  }\n\n  return false;\n}\n\nfunction truthy(x) {\n  return x !== false && x != null;\n} /////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\n\nexport var erlang = {\n  startState: function startState() {\n    return {\n      tokenStack: [],\n      in_string: false,\n      in_atom: false\n    };\n  },\n  token: tokenizer,\n  indent: indenter,\n  languageData: {\n    commentTokens: {\n      line: \"%\"\n    }\n  }\n};"],"sourceRoot":""}