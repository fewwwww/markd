{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/fcl.js"],"names":["keywords","start_blocks","end_blocks","atoms","isOperatorChar","tokenBase","stream","state","ch","next","test","match","eat","tokenize","tokenComment","skipToEnd","eatWhile","cur","current","toLowerCase","propertyIsEnumerable","maybeEnd","Context","indented","column","type","align","prev","this","fcl","startState","indentUnit","context","startOfLine","token","ctx","sol","indentation","eatSpace","style","col","pushContext","popContext","indent","textAfter","cx","closing","unit","languageData","commentTokens","line","block","open","close"],"mappings":"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","file":"static/js/44.23ad7758.chunk.js","sourcesContent":["var keywords = {\n  \"term\": true,\n  \"method\": true,\n  \"accu\": true,\n  \"rule\": true,\n  \"then\": true,\n  \"is\": true,\n  \"and\": true,\n  \"or\": true,\n  \"if\": true,\n  \"default\": true\n};\nvar start_blocks = {\n  \"var_input\": true,\n  \"var_output\": true,\n  \"fuzzify\": true,\n  \"defuzzify\": true,\n  \"function_block\": true,\n  \"ruleblock\": true\n};\nvar end_blocks = {\n  \"end_ruleblock\": true,\n  \"end_defuzzify\": true,\n  \"end_function_block\": true,\n  \"end_fuzzify\": true,\n  \"end_var\": true\n};\nvar atoms = {\n  \"true\": true,\n  \"false\": true,\n  \"nan\": true,\n  \"real\": true,\n  \"min\": true,\n  \"max\": true,\n  \"cog\": true,\n  \"cogs\": true\n};\nvar isOperatorChar = /[+\\-*&^%:=<>!|\\/]/;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (/[\\d\\.]/.test(ch)) {\n    if (ch == \".\") {\n      stream.match(/^[0-9]+([eE][\\-+]?[0-9]+)?/);\n    } else if (ch == \"0\") {\n      stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);\n    } else {\n      stream.match(/^[0-9]*\\.?[0-9]*([eE][\\-+]?[0-9]+)?/);\n    }\n\n    return \"number\";\n  }\n\n  if (ch == \"/\" || ch == \"(\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n  var cur = stream.current().toLowerCase();\n\n  if (keywords.propertyIsEnumerable(cur) || start_blocks.propertyIsEnumerable(cur) || end_blocks.propertyIsEnumerable(cur)) {\n    return \"keyword\";\n  }\n\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if ((ch == \"/\" || ch == \")\") && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return \"comment\";\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\n\nfunction pushContext(state, col, type) {\n  return state.context = new Context(state.indented, col, type, null, state.context);\n}\n\nfunction popContext(state) {\n  if (!state.context.prev) return;\n  var t = state.context.type;\n  if (t == \"end_block\") state.indented = state.context.indented;\n  return state.context = state.context.prev;\n} // Interface\n\n\nexport var fcl = {\n  startState: function startState(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n  token: function token(stream, state) {\n    var ctx = state.context;\n\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n\n    if (stream.eatSpace()) return null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\") return style;\n    if (ctx.align == null) ctx.align = true;\n    var cur = stream.current().toLowerCase();\n    if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), \"end_block\");else if (end_blocks.propertyIsEnumerable(cur)) popContext(state);\n    state.startOfLine = false;\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return 0;\n    var ctx = state.context;\n    var closing = end_blocks.propertyIsEnumerable(textAfter);\n    if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"(*\",\n        close: \"*)\"\n      }\n    }\n  }\n};"],"sourceRoot":""}