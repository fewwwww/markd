{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/tiki.js"],"names":["inBlock","style","terminator","returnTokenizer","stream","state","eol","match","tokenize","inText","next","inLine","chain","parser","sol","ch","eat","eatSpace","eatWhile","inPlugin","pluginName","type","curState","setStyle","quote","peek","test","pass","i","arguments","length","cc","push","cont","apply","pushContext","startOfLine","noIndent","context","prev","indent","indented","popContext","element","attributes","err","endcloseplugin","name","attvalue","attvaluemaybe","tiki","startState","token","indentation","pop","textAfter","cx","unit"],"mappings":"qGAAA,SAASA,EAAQC,EAAOC,EAAYC,GAClC,OAAO,SAAUC,EAAQC,GACvB,MAAQD,EAAOE,OAAO,CACpB,GAAIF,EAAOG,MAAML,GAAa,CAC5BG,EAAMG,SAAWC,EACjB,MAGFL,EAAOM,OAIT,OADIP,IAAiBE,EAAMG,SAAWL,GAC/BF,GAIX,SAASU,EAAOV,GACd,OAAO,SAAUG,EAAQC,GACvB,MAAQD,EAAOE,OACbF,EAAOM,OAIT,OADAL,EAAMG,SAAWC,EACVR,GAIX,SAASQ,EAAOL,EAAQC,GACtB,SAASO,EAAMC,GAEb,OADAR,EAAMG,SAAWK,EACVA,EAAOT,EAAQC,GAGxB,IAAIS,EAAMV,EAAOU,MACbC,EAAKX,EAAOM,OAEhB,OAAQK,GAEN,IAAK,IAMH,OAJAX,EAAOY,IAAI,KACXZ,EAAOa,WACPb,EAAOc,SAAS,yBAChBb,EAAMG,SAAWW,EACV,MAET,IAAK,IAEH,GAAIf,EAAOY,IAAI,KAAM,OAAOJ,EAAMZ,EAAQ,SAAU,KAAMS,IAC1D,MAEF,IAAK,IAEH,GAAIL,EAAOY,IAAI,KAAM,OAAOJ,EAAMZ,EAAQ,KAAM,KAAMS,IACtD,MAEF,IAAK,IAEH,GAAIL,EAAOY,IAAI,KAAM,OAAOJ,EAAMZ,EAAQ,OAAQ,KAAMS,IACxD,MAEF,IAAK,IAEH,OAAOG,EAAMZ,EAAQ,MAAO,IAAKS,IAGnC,IAAK,IAEH,GAAIL,EAAOY,IAAI,KAAM,OAAOJ,EAAMZ,EAAQ,UAAW,OACrD,MAEF,IAAK,IACH,GAAII,EAAOY,IAAI,KAEb,OAAOJ,EAAMZ,EAAQ,gBAAiB,KAAMS,IACvC,GAAIL,EAAOY,IAAI,KAEpB,OAAOJ,EAAMZ,EAAQ,mBAAoB,KAAMS,IAGjD,MAEF,IAAK,IAEH,GAAIL,EAAOG,MAAM,MAAO,OAAOK,EAAMZ,EAAQ,eAAgB,MAAOS,IACpE,MAEF,IAAK,IACH,GAAIL,EAAOY,IAAI,KAAM,OAAOJ,EAAMZ,EAAQ,UAAW,OACrD,MAEF,IAAK,IAEH,OAAOY,EAAMZ,EAAQ,SAAU,MAGjC,IAAK,IAEH,GAAII,EAAOG,MAAM,OAAQ,OAAOK,EAAMZ,EAAQ,OAAQ,UAK1D,GAAIc,EACF,OAAQC,GACN,IAAK,IAEH,OAAIX,EAAOG,MAAM,SACRK,EAAMD,EAAO,kBACXP,EAAOG,MAAM,QACfK,EAAMD,EAAO,kBACXP,EAAOG,MAAM,OACfK,EAAMD,EAAO,mBACXP,EAAOG,MAAM,MACfK,EAAMD,EAAO,mBAOxB,IAAK,IAEL,IAAK,IAEL,IAAK,IAEH,OAAOC,EAAMD,EAAO,wBAM1B,OAAO,KAIT,IAAIS,EAAYC,EAiEZC,EAAUC,EA/Dd,SAASJ,EAASf,EAAQC,GACxB,IAiCmBmB,EAjCfT,EAAKX,EAAOM,OACZe,EAAOrB,EAAOqB,OAElB,MAAU,KAANV,GACFV,EAAMG,SAAWC,EAEV,OACQ,KAANM,GAAmB,KAANA,EACf,UACQ,KAANA,GACTM,EAAO,SAEK,KAARI,IACFrB,EAAOM,OACPe,EAAOrB,EAAOqB,QAIX,SAASC,KAAKD,KACjBpB,EAAMG,SA4BH,SAAUJ,EAAQC,GACvB,MAAQD,EAAOE,OAAO,CACpB,IAAIS,EAAKX,EAAOM,OACZe,EAAOrB,EAAOqB,OAElB,GAAU,KAANV,GAAmB,KAANA,GAAa,QAAQW,KAAKD,GAAO,CAChDpB,EAAMG,SAAWW,EACjB,OAIJ,MAAO,WAnCA,YACE,SAASO,KAAKX,IACvBV,EAAMG,UAQWgB,EARYT,EASxB,SAAUX,EAAQC,GACvB,MAAQD,EAAOE,OACb,GAAIF,EAAOM,QAAUc,EAAO,CAC1BnB,EAAMG,SAAWW,EACjB,MAIJ,MAAO,WAhBAd,EAAMG,SAASJ,EAAQC,KAE9BD,EAAOc,SAAS,uBACT,WAmCX,SAASS,IACP,IAAK,IAAIC,EAAIC,UAAUC,OAAS,EAAGF,GAAK,EAAGA,IACzCN,EAASS,GAAGC,KAAKH,UAAUD,IAI/B,SAASK,IAEP,OADAN,EAAKO,MAAM,KAAML,YACV,EAGT,SAASM,EAAYf,EAAYgB,GAC/B,IAAIC,EAAWf,EAASgB,SAAWhB,EAASgB,QAAQD,SACpDf,EAASgB,QAAU,CACjBC,KAAMjB,EAASgB,QACflB,WAAYA,EACZoB,OAAQlB,EAASmB,SACjBL,YAAaA,EACbC,SAAUA,GAId,SAASK,IACHpB,EAASgB,UAAShB,EAASgB,QAAUhB,EAASgB,QAAQC,MAG5D,SAASI,EAAQtB,GACf,GAAY,cAARA,EAEF,OADAC,EAASF,WAAaA,EACfa,EAAKW,GAoBGR,EApBmBd,EAASc,YAqBtC,SAAUf,GACf,MAAY,mBAARA,GAAqC,aAARA,EAA4BY,IAEjD,aAARZ,GACFc,EAAYb,EAASF,WAAYgB,GAC1BH,KAGFA,OA5BF,GAAY,eAARZ,EAAuB,CAChC,IAAIwB,GAAM,EAUV,OARIvB,EAASgB,SACXO,EAAMvB,EAASgB,QAAQlB,YAAcA,EACrCsB,KAEAG,GAAM,EAGJA,IAAKtB,EAAW,SACbU,EAqBX,SAAwBY,GACtB,OAAO,SAAUxB,GAEf,OADIwB,IAAKtB,EAAW,SACR,aAARF,EAA4BY,IACzBN,KAzBKmB,CAAeD,IACtB,MAAY,UAARxB,GACJC,EAASgB,SAAoC,UAAzBhB,EAASgB,QAAQS,MAAkBZ,EAAY,UACpEb,EAASd,UAAYC,GAAQiC,IAC1BT,KACKA,IAGhB,IAAmBG,EAqBnB,SAASQ,EAAWvB,GAClB,MAAY,WAARA,GACFE,EAAW,YACJU,EAAKW,IAGF,UAARvB,EAAyBY,EAAKe,EAAUJ,GACrCjB,IAGT,SAASqB,EAAS3B,GAChB,MAAY,WAARA,GACFE,EAAW,SACJU,KAGG,UAARZ,EAAyBY,EAAKgB,GAC3BtB,IAGT,SAASsB,EAAc5B,GACrB,MAAY,UAARA,EAAyBY,EAAKgB,GAA2BtB,IAvS/D,4CA0SO,IAAIuB,EAAO,CAChBC,WAAY,WACV,MAAO,CACL3C,SAAUC,EACVsB,GAAI,GACJU,SAAU,EACVL,aAAa,EACbhB,WAAY,KACZkB,QAAS,OAGbc,MAAO,SAAehD,EAAQC,GAM5B,GALID,EAAOU,QACTT,EAAM+B,aAAc,EACpB/B,EAAMoC,SAAWrC,EAAOiD,eAGtBjD,EAAOa,WAAY,OAAO,KAC9BM,EAAWF,EAAOD,EAAa,KAC/B,IAAInB,EAAQI,EAAMG,SAASJ,EAAQC,GAEnC,IAAKJ,GAASoB,IAAkB,WAATpB,EAGrB,IAFAqB,EAAWjB,IAEE,CAEX,IADWA,EAAM0B,GAAGuB,OAASX,GACpBtB,GAAQpB,GAAQ,MAK7B,OADAI,EAAM+B,aAAc,EACbb,GAAYtB,GAErBuC,OAAQ,SAAgBnC,EAAOkD,EAAWC,GACxC,IAAIlB,EAAUjC,EAAMiC,QACpB,GAAIA,GAAWA,EAAQD,SAAU,OAAO,EAGxC,IAFIC,GAAW,OAAOZ,KAAK6B,KAAYjB,EAAUA,EAAQC,MAElDD,IAAYA,EAAQF,aACzBE,EAAUA,EAAQC,KAGpB,OAAID,EAAgBA,EAAQE,OAASgB,EAAGC,KAAiB","file":"static/js/92.9aaf2eaf.chunk.js","sourcesContent":["function inBlock(style, terminator, returnTokenizer) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.match(terminator)) {\n        state.tokenize = inText;\n        break;\n      }\n\n      stream.next();\n    }\n\n    if (returnTokenizer) state.tokenize = returnTokenizer;\n    return style;\n  };\n}\n\nfunction inLine(style) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      stream.next();\n    }\n\n    state.tokenize = inText;\n    return style;\n  };\n}\n\nfunction inText(stream, state) {\n  function chain(parser) {\n    state.tokenize = parser;\n    return parser(stream, state);\n  }\n\n  var sol = stream.sol();\n  var ch = stream.next(); //non start of line\n\n  switch (ch) {\n    //switch is generally much faster than if, so it is used here\n    case \"{\":\n      //plugin\n      stream.eat(\"/\");\n      stream.eatSpace();\n      stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?(}]/);\n      state.tokenize = inPlugin;\n      return \"tag\";\n\n    case \"_\":\n      //bold\n      if (stream.eat(\"_\")) return chain(inBlock(\"strong\", \"__\", inText));\n      break;\n\n    case \"'\":\n      //italics\n      if (stream.eat(\"'\")) return chain(inBlock(\"em\", \"''\", inText));\n      break;\n\n    case \"(\":\n      // Wiki Link\n      if (stream.eat(\"(\")) return chain(inBlock(\"link\", \"))\", inText));\n      break;\n\n    case \"[\":\n      // Weblink\n      return chain(inBlock(\"url\", \"]\", inText));\n      break;\n\n    case \"|\":\n      //table\n      if (stream.eat(\"|\")) return chain(inBlock(\"comment\", \"||\"));\n      break;\n\n    case \"-\":\n      if (stream.eat(\"=\")) {\n        //titleBar\n        return chain(inBlock(\"header string\", \"=-\", inText));\n      } else if (stream.eat(\"-\")) {\n        //deleted\n        return chain(inBlock(\"error tw-deleted\", \"--\", inText));\n      }\n\n      break;\n\n    case \"=\":\n      //underline\n      if (stream.match(\"==\")) return chain(inBlock(\"tw-underline\", \"===\", inText));\n      break;\n\n    case \":\":\n      if (stream.eat(\":\")) return chain(inBlock(\"comment\", \"::\"));\n      break;\n\n    case \"^\":\n      //box\n      return chain(inBlock(\"tw-box\", \"^\"));\n      break;\n\n    case \"~\":\n      //np\n      if (stream.match(\"np~\")) return chain(inBlock(\"meta\", \"~/np~\"));\n      break;\n  } //start of line types\n\n\n  if (sol) {\n    switch (ch) {\n      case \"!\":\n        //header at start of line\n        if (stream.match('!!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!')) {\n          return chain(inLine(\"header string\"));\n        } else {\n          return chain(inLine(\"header string\"));\n        }\n\n        break;\n\n      case \"*\": //unordered list line item, or <li /> at start of line\n\n      case \"#\": //ordered list line item, or <li /> at start of line\n\n      case \"+\":\n        //ordered list line item, or <li /> at start of line\n        return chain(inLine(\"tw-listitem bracket\"));\n        break;\n    }\n  } //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki\n\n\n  return null;\n} // Return variables for tokenizers\n\n\nvar pluginName, type;\n\nfunction inPlugin(stream, state) {\n  var ch = stream.next();\n  var peek = stream.peek();\n\n  if (ch == \"}\") {\n    state.tokenize = inText; //type = ch == \")\" ? \"endPlugin\" : \"selfclosePlugin\"; inPlugin\n\n    return \"tag\";\n  } else if (ch == \"(\" || ch == \")\") {\n    return \"bracket\";\n  } else if (ch == \"=\") {\n    type = \"equals\";\n\n    if (peek == \">\") {\n      stream.next();\n      peek = stream.peek();\n    } //here we detect values directly after equal character with no quotes\n\n\n    if (!/[\\'\\\"]/.test(peek)) {\n      state.tokenize = inAttributeNoQuote();\n    } //end detect values\n\n\n    return \"operator\";\n  } else if (/[\\'\\\"]/.test(ch)) {\n    state.tokenize = inAttribute(ch);\n    return state.tokenize(stream, state);\n  } else {\n    stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?]/);\n    return \"keyword\";\n  }\n}\n\nfunction inAttribute(quote) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.next() == quote) {\n        state.tokenize = inPlugin;\n        break;\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nfunction inAttributeNoQuote() {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      var ch = stream.next();\n      var peek = stream.peek();\n\n      if (ch == \" \" || ch == \",\" || /[ )}]/.test(peek)) {\n        state.tokenize = inPlugin;\n        break;\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nvar curState, setStyle;\n\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) {\n    curState.cc.push(arguments[i]);\n  }\n}\n\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\n\nfunction pushContext(pluginName, startOfLine) {\n  var noIndent = curState.context && curState.context.noIndent;\n  curState.context = {\n    prev: curState.context,\n    pluginName: pluginName,\n    indent: curState.indented,\n    startOfLine: startOfLine,\n    noIndent: noIndent\n  };\n}\n\nfunction popContext() {\n  if (curState.context) curState.context = curState.context.prev;\n}\n\nfunction element(type) {\n  if (type == \"openPlugin\") {\n    curState.pluginName = pluginName;\n    return cont(attributes, endplugin(curState.startOfLine));\n  } else if (type == \"closePlugin\") {\n    var err = false;\n\n    if (curState.context) {\n      err = curState.context.pluginName != pluginName;\n      popContext();\n    } else {\n      err = true;\n    }\n\n    if (err) setStyle = \"error\";\n    return cont(endcloseplugin(err));\n  } else if (type == \"string\") {\n    if (!curState.context || curState.context.name != \"!cdata\") pushContext(\"!cdata\");\n    if (curState.tokenize == inText) popContext();\n    return cont();\n  } else return cont();\n}\n\nfunction endplugin(startOfLine) {\n  return function (type) {\n    if (type == \"selfclosePlugin\" || type == \"endPlugin\") return cont();\n\n    if (type == \"endPlugin\") {\n      pushContext(curState.pluginName, startOfLine);\n      return cont();\n    }\n\n    return cont();\n  };\n}\n\nfunction endcloseplugin(err) {\n  return function (type) {\n    if (err) setStyle = \"error\";\n    if (type == \"endPlugin\") return cont();\n    return pass();\n  };\n}\n\nfunction attributes(type) {\n  if (type == \"keyword\") {\n    setStyle = \"attribute\";\n    return cont(attributes);\n  }\n\n  if (type == \"equals\") return cont(attvalue, attributes);\n  return pass();\n}\n\nfunction attvalue(type) {\n  if (type == \"keyword\") {\n    setStyle = \"string\";\n    return cont();\n  }\n\n  if (type == \"string\") return cont(attvaluemaybe);\n  return pass();\n}\n\nfunction attvaluemaybe(type) {\n  if (type == \"string\") return cont(attvaluemaybe);else return pass();\n}\n\nexport var tiki = {\n  startState: function startState() {\n    return {\n      tokenize: inText,\n      cc: [],\n      indented: 0,\n      startOfLine: true,\n      pluginName: null,\n      context: null\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      state.startOfLine = true;\n      state.indented = stream.indentation();\n    }\n\n    if (stream.eatSpace()) return null;\n    setStyle = type = pluginName = null;\n    var style = state.tokenize(stream, state);\n\n    if ((style || type) && style != \"comment\") {\n      curState = state;\n\n      while (true) {\n        var comb = state.cc.pop() || element;\n        if (comb(type || style)) break;\n      }\n    }\n\n    state.startOfLine = false;\n    return setStyle || style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    var context = state.context;\n    if (context && context.noIndent) return 0;\n    if (context && /^{\\//.test(textAfter)) context = context.prev;\n\n    while (context && !context.startOfLine) {\n      context = context.prev;\n    }\n\n    if (context) return context.indent + cx.unit;else return 0;\n  }\n};"],"sourceRoot":""}