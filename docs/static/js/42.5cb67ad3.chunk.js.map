{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/elm.js"],"names":["switchState","source","setState","f","lowerRE","upperRE","innerRE","digitRE","hexRE","symbolRE","specialRE","spacesRE","normal","eatWhile","char","next","test","eat","chompMultiComment","nest","eol","match","chompGlsl","chompChar","chompMultiString","chompSingleString","isDef","pos","skipToEnd","skipTo","wellKnownWords","case","of","as","if","then","else","let","in","type","alias","module","where","import","exposing","port","elm","startState","copyState","s","token","stream","state","word","current","hasOwnProperty"],"mappings":"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","file":"static/js/42.5cb67ad3.chunk.js","sourcesContent":["function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\nvar lowerRE = /[a-z]/;\nvar upperRE = /[A-Z]/;\nvar innerRE = /[a-zA-Z0-9_]/;\nvar digitRE = /[0-9]/;\nvar hexRE = /[0-9A-Fa-f]/;\nvar symbolRE = /[-&*+.\\\\/<>=?^|:]/;\nvar specialRE = /[(),[\\]{}]/;\nvar spacesRE = /[ \\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal() {\n  return function (source, setState) {\n    if (source.eatWhile(spacesRE)) {\n      return null;\n    }\n\n    var char = source.next();\n\n    if (specialRE.test(char)) {\n      return char === '{' && source.eat('-') ? switchState(source, setState, chompMultiComment(1)) : char === '[' && source.match('glsl|') ? switchState(source, setState, chompGlsl) : 'builtin';\n    }\n\n    if (char === '\\'') {\n      return switchState(source, setState, chompChar);\n    }\n\n    if (char === '\"') {\n      return source.eat('\"') ? source.eat('\"') ? switchState(source, setState, chompMultiString) : 'string' : switchState(source, setState, chompSingleString);\n    }\n\n    if (upperRE.test(char)) {\n      source.eatWhile(innerRE);\n      return 'type';\n    }\n\n    if (lowerRE.test(char)) {\n      var isDef = source.pos === 1;\n      source.eatWhile(innerRE);\n      return isDef ? \"def\" : \"variable\";\n    }\n\n    if (digitRE.test(char)) {\n      if (char === '0') {\n        if (source.eat(/[xX]/)) {\n          source.eatWhile(hexRE); // should require at least 1\n\n          return \"number\";\n        }\n      } else {\n        source.eatWhile(digitRE);\n      }\n\n      if (source.eat('.')) {\n        source.eatWhile(digitRE); // should require at least 1\n      }\n\n      if (source.eat(/[eE]/)) {\n        source.eat(/[-+]/);\n        source.eatWhile(digitRE); // should require at least 1\n      }\n\n      return \"number\";\n    }\n\n    if (symbolRE.test(char)) {\n      if (char === '-' && source.eat('-')) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n\n      source.eatWhile(symbolRE);\n      return \"keyword\";\n    }\n\n    if (char === '_') {\n      return \"keyword\";\n    }\n\n    return \"error\";\n  };\n}\n\nfunction chompMultiComment(nest) {\n  if (nest == 0) {\n    return normal();\n  }\n\n  return function (source, setState) {\n    while (!source.eol()) {\n      var char = source.next();\n\n      if (char == '{' && source.eat('-')) {\n        ++nest;\n      } else if (char == '-' && source.eat('}')) {\n        --nest;\n\n        if (nest === 0) {\n          setState(normal());\n          return 'comment';\n        }\n      }\n    }\n\n    setState(chompMultiComment(nest));\n    return 'comment';\n  };\n}\n\nfunction chompMultiString(source, setState) {\n  while (!source.eol()) {\n    var char = source.next();\n\n    if (char === '\"' && source.eat('\"') && source.eat('\"')) {\n      setState(normal());\n      return 'string';\n    }\n  }\n\n  return 'string';\n}\n\nfunction chompSingleString(source, setState) {\n  while (source.skipTo('\\\\\"')) {\n    source.next();\n    source.next();\n  }\n\n  if (source.skipTo('\"')) {\n    source.next();\n    setState(normal());\n    return 'string';\n  }\n\n  source.skipToEnd();\n  setState(normal());\n  return 'error';\n}\n\nfunction chompChar(source, setState) {\n  while (source.skipTo(\"\\\\'\")) {\n    source.next();\n    source.next();\n  }\n\n  if (source.skipTo(\"'\")) {\n    source.next();\n    setState(normal());\n    return 'string';\n  }\n\n  source.skipToEnd();\n  setState(normal());\n  return 'error';\n}\n\nfunction chompGlsl(source, setState) {\n  while (!source.eol()) {\n    var char = source.next();\n\n    if (char === '|' && source.eat(']')) {\n      setState(normal());\n      return 'string';\n    }\n  }\n\n  return 'string';\n}\n\nvar wellKnownWords = {\n  case: 1,\n  of: 1,\n  as: 1,\n  if: 1,\n  then: 1,\n  else: 1,\n  let: 1,\n  in: 1,\n  type: 1,\n  alias: 1,\n  module: 1,\n  where: 1,\n  import: 1,\n  exposing: 1,\n  port: 1\n};\nexport var elm = {\n  startState: function startState() {\n    return {\n      f: normal()\n    };\n  },\n  copyState: function copyState(s) {\n    return {\n      f: s.f\n    };\n  },\n  token: function token(stream, state) {\n    var type = state.f(stream, function (s) {\n      state.f = s;\n    });\n    var word = stream.current();\n    return wellKnownWords.hasOwnProperty(word) ? 'keyword' : type;\n  }\n};"],"sourceRoot":""}