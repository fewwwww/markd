{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/dtd.js"],"names":["type","ret","style","tp","tokenBase","stream","state","quote","terminator","ch","next","eat","tokenize","eol","match","eatWhile","escaped","sc","current","substr","length","backUp","tokenSGMLComment","dashes","dtd","startState","baseIndent","stack","token","eatSpace","context","push","pop","indent","textAfter","cx","n","charAt","unit","languageData","indentOnInput"],"mappings":"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","file":"static/js/37.abdd04b5.chunk.js","sourcesContent":["var type;\n\nfunction ret(style, tp) {\n  type = tp;\n  return style;\n}\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (ch == \"<\" && stream.eat(\"!\")) {\n    if (stream.eatWhile(/[\\-]/)) {\n      state.tokenize = tokenSGMLComment;\n      return tokenSGMLComment(stream, state);\n    } else if (stream.eatWhile(/[\\w]/)) return ret(\"keyword\", \"doindent\");\n  } else if (ch == \"<\" && stream.eat(\"?\")) {\n    //xml declaration\n    state.tokenize = inBlock(\"meta\", \"?>\");\n    return ret(\"meta\", ch);\n  } else if (ch == \"#\" && stream.eatWhile(/[\\w]/)) return ret(\"atom\", \"tag\");else if (ch == \"|\") return ret(\"keyword\", \"separator\");else if (ch.match(/[\\(\\)\\[\\]\\-\\.,\\+\\?>]/)) return ret(null, ch); //if(ch === \">\") return ret(null, \"endtag\"); else\n  else if (ch.match(/[\\[\\]]/)) return ret(\"rule\", ch);else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (stream.eatWhile(/[a-zA-Z\\?\\+\\d]/)) {\n      var sc = stream.current();\n      if (sc.substr(sc.length - 1, sc.length).match(/\\?|\\+/) !== null) stream.backUp(1);\n      return ret(\"tag\", \"tag\");\n    } else if (ch == \"%\" || ch == \"*\") return ret(\"number\", \"number\");else {\n      stream.eatWhile(/[\\w\\\\\\-_%.{,]/);\n      return ret(null, null);\n    }\n}\n\nfunction tokenSGMLComment(stream, state) {\n  var dashes = 0,\n      ch;\n\n  while ((ch = stream.next()) != null) {\n    if (dashes >= 2 && ch == \">\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    dashes = ch == \"-\" ? dashes + 1 : 0;\n  }\n\n  return ret(\"comment\", \"comment\");\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n        ch;\n\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) {\n        state.tokenize = tokenBase;\n        break;\n      }\n\n      escaped = !escaped && ch == \"\\\\\";\n    }\n\n    return ret(\"string\", \"tag\");\n  };\n}\n\nfunction inBlock(style, terminator) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      if (stream.match(terminator)) {\n        state.tokenize = tokenBase;\n        break;\n      }\n\n      stream.next();\n    }\n\n    return style;\n  };\n}\n\nexport var dtd = {\n  startState: function startState() {\n    return {\n      tokenize: tokenBase,\n      baseIndent: 0,\n      stack: []\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    var context = state.stack[state.stack.length - 1];\n    if (stream.current() == \"[\" || type === \"doindent\" || type == \"[\") state.stack.push(\"rule\");else if (type === \"endtag\") state.stack[state.stack.length - 1] = \"endtag\";else if (stream.current() == \"]\" || type == \"]\" || type == \">\" && context == \"rule\") state.stack.pop();else if (type == \"[\") state.stack.push(\"[\");\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    var n = state.stack.length;\n    if (textAfter.charAt(0) === ']') n--;else if (textAfter.substr(textAfter.length - 1, textAfter.length) === \">\") {\n      if (textAfter.substr(0, 1) === \"<\") {} else if (type == \"doindent\" && textAfter.length > 1) {} else if (type == \"doindent\") n--;else if (type == \">\" && textAfter.length > 1) {} else if (type == \"tag\" && textAfter !== \">\") {} else if (type == \"tag\" && state.stack[state.stack.length - 1] == \"rule\") n--;else if (type == \"tag\") n++;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\" && type === \">\") n--;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\") {} else if (textAfter.substr(0, 1) !== \"<\" && textAfter.substr(0, 1) === \">\") n = n - 1;else if (textAfter === \">\") {} else n = n - 1; //over rule them all\n\n\n      if (type == null || type == \"]\") n--;\n    }\n    return state.baseIndent + n * cx.unit;\n  },\n  languageData: {\n    indentOnInput: /^\\s*[\\]>]$/\n  }\n};"],"sourceRoot":""}