{"version":3,"sources":["../node_modules/@lezer/xml/dist/index.es.js","../node_modules/@codemirror/lang-xml/dist/index.js"],"names":["nameChar","ch","cachedName","cachedInput","cachedPos","tagNameAfter","input","offset","pos","peek","name","next","String","fromCharCode","ElementContext","parent","this","hash","i","length","charCodeAt","elementContext","start","shift","context","term","stack","reduce","reuse","node","_stack","type","id","strict","startTag","advance","acceptToken","cx","contextual","scanTo","end","endPos","len","commentContent","piContent","cdataContent","parser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","closedBy","openedBy","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","tokenPrec","tagName","doc","tag","getChild","sliceString","from","to","elementName","tree","firstChild","findParentElement","cur","Element","spec","attrs","attrValues","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","concat","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","done","_s","value","push","global","values","err","return","allElements","topElements","byName","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_loop","attrVals","attributes","find","a","elt","top","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_a","state","loc","at","resolveInner","inTag","lastChild","isError","before","childBefore","findLocation","explicit","parentName","options","span","_parentName","_parent","attr","getChildren","attrName","_parent2","_parentName2","_parent3","closing","last","e","openTag","sliceDoc","xmlLanguage","define","configure","props","add","closed","textAfter","lineIndent","unit","column","subtree","first","AttributeValue","string","Text","content","angleBracket","TagName","invalid","AttributeName","propertyName","UnquotedAttributeValue","Is","definitionOperator","character","Comment","blockComment","ProcessingInst","processingInstruction","DoctypeDecl","documentMeta","Cdata","special","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","arguments","data","of","autocomplete","elements"],"mappings":"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","file":"static/js/23.911e229c.chunk.js","sourcesContent":["import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { NodeProp } from '@lezer/common'; // This file was generated by lezer-generator. You probably shouldn't edit it.\n\nvar StartTag = 1,\n    StartCloseTag = 2,\n    MissingCloseTag = 3,\n    mismatchedStartCloseTag = 4,\n    incompleteStartCloseTag = 5,\n    commentContent$1 = 36,\n    piContent$1 = 37,\n    cdataContent$1 = 38,\n    Element = 10,\n    OpenTag = 12;\n/* Hand-written tokenizer for XML tag matching. */\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;\n}\n\nfunction isSpace(ch) {\n  return ch == 9 || ch == 10 || ch == 13 || ch == 32;\n}\n\nvar cachedName = null,\n    cachedInput = null,\n    cachedPos = 0;\n\nfunction tagNameAfter(input, offset) {\n  var pos = input.pos + offset;\n  if (cachedInput == input && cachedPos == pos) return cachedName;\n\n  while (isSpace(input.peek(offset))) {\n    offset++;\n  }\n\n  var name = \"\";\n\n  for (;;) {\n    var next = input.peek(offset);\n    if (!nameChar(next)) break;\n    name += String.fromCharCode(next);\n    offset++;\n  }\n\n  cachedInput = input;\n  cachedPos = pos;\n  return cachedName = name || null;\n}\n\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n  this.hash = parent ? parent.hash : 0;\n\n  for (var i = 0; i < name.length; i++) {\n    this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);\n  }\n}\n\nvar elementContext = new ContextTracker({\n  start: null,\n  shift: function shift(context, term, stack, input) {\n    return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context;\n  },\n  reduce: function reduce(context, term) {\n    return term == Element && context ? context.parent : context;\n  },\n  reuse: function reuse(context, node, _stack, input) {\n    var type = node.type.id;\n    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context;\n  },\n  hash: function hash(context) {\n    return context ? context.hash : 0;\n  },\n  strict: false\n});\nvar startTag = new ExternalTokenizer(function (input, stack) {\n  if (input.next != 60\n  /* '<' */\n  ) return;\n  input.advance();\n\n  if (input.next == 47\n  /* '/' */\n  ) {\n      input.advance();\n      var name = tagNameAfter(input, 0);\n      if (!name) return input.acceptToken(incompleteStartCloseTag);\n      if (stack.context && name == stack.context.name) return input.acceptToken(StartCloseTag);\n\n      for (var cx = stack.context; cx; cx = cx.parent) {\n        if (cx.name == name) return input.acceptToken(MissingCloseTag, -2);\n      }\n\n      input.acceptToken(mismatchedStartCloseTag);\n    } else if (input.next != 33\n  /* '!' */\n  && input.next != 63\n  /* '?' */\n  ) {\n      return input.acceptToken(StartTag);\n    }\n}, {\n  contextual: true\n});\n\nfunction scanTo(type, end) {\n  return new ExternalTokenizer(function (input) {\n    for (var endPos = 0, len = 0;; len++) {\n      if (input.next < 0) {\n        if (len) input.acceptToken(type);\n        break;\n      }\n\n      if (input.next == end.charCodeAt(endPos)) {\n        endPos++;\n\n        if (endPos == end.length) {\n          if (len > end.length) input.acceptToken(type, 1 - end.length);\n          break;\n        }\n      } else {\n        endPos = 0;\n      }\n\n      input.advance();\n    }\n  });\n}\n\nvar commentContent = scanTo(commentContent$1, \"-->\");\nvar piContent = scanTo(piContent$1, \"?>\");\nvar cdataContent = scanTo(cdataContent$1, \"?>\"); // This file was generated by lezer-generator. You probably shouldn't edit it.\n\nvar parser = LRParser.deserialize({\n  version: 13,\n  states: \"-OOQOaOOOcObO'#CcOkOdO'#CdOOOP'#Cv'#CvOsOaO'#DTO!XOaOOOOOQ'#Cw'#CwO!aObO,58}OOOP,58},58}OOOS'#Cx'#CxO!iOdO,59OOOOP,59O,59OOOOP-E6t-E6tO!qO`O'#ChO#kOqO'#CfOOOP'#Cf'#CfO#rOaO'#CyQ$TOPOOO$YOaOOOOOQ-E6u-E6uOOOP1G.i1G.iOOOS-E6v-E6vOOOP1G.j1G.jOOOO'#Cz'#CzO$hO`O,59SO$pO!bO,59SO%OOhO'#CqO%WO`O'#CrOOOP'#D]'#D]OOOP'#C}'#C}O%`OqO,59QO%gO`O'#CsOOOP,59Q,59QOOOP,59e,59eOOOP-E6w-E6wO$TOPOOOOOO-E6x-E6xO%oO!bO1G.nO%oO!bO1G.nO%}O`O'#CjO&VO!bO'#C{O&eO!bO1G.nOOOP1G.n1G.nOOOP1G.{1G.{OOOW'#DO'#DOO&pOhO,59]OOOP,59],59]O&xO`O,59^O'QO`O,59^OOOP-E6{-E6{OOOP1G.l1G.lO'YO`O,59_O'bO`O,59_O'jO!bO7+$YO'xO!bO7+$YOOOP7+$Y7+$YOOOP7+$g7+$gO(TO`O,59UO(]O`O,59UO(eO!bO,59gOOOO-E6y-E6yOOOW-E6|-E6|OOOP1G.w1G.wO(sO`O1G.xO(sO`O1G.xOOOP1G.x1G.xO({O`O1G.yO({O`O1G.yOOOP1G.y1G.yO)TO!bO<<GtOOOP<<Gt<<GtOOOP<<HR<<HRO(]O`O1G.pO(]O`O1G.pO)`O#tO'#CmOOOO1G.p1G.pO)nO`O7+$dOOOP7+$d7+$dO)vO`O7+$eOOOP7+$e7+$eOOOPAN=`AN=`OOOPAN=mAN=mO(]O`O7+$[OOOO7+$[7+$[OOOO'#C|'#C|O*OO#tO,59XOOOO,59X,59XOOOP<<HO<<HOOOOP<<HP<<HPOOOO<<Gv<<GvOOOO-E6z-E6zOOOO1G.s1G.s\",\n  stateData: \"*^~OyPOzRO|QOPwPXwP~OtUOxWO~OuXO{ZO~OyPOzRO|QOPwXXwXswX~OP]OXbO~OtUOxdO~OuXO{fO~O]iOzgO~OP]OQoOSkOTlOblOclOdlOyPO|QO!RjO~ORpO~P!yOyPOzRO|QOPwPswP~OP]O~OyPOzRO|QOPwP~O]uOzgO~OZzO_wOh{OzgO~Ov|O!Q!OO~O]!QOzgO~OR!SO~P!yO]!UOzgO~OZ!XO_wOh!YOzgO~O`![OzgO~OzgOZoX_oXhoX~OZ!XO_wOh!YO~Ov|O!Q!`O~O]!aOzgO~OZ!cOzgO~O]!dOzgO~OZ!fOzgO~OZ!hO_wOh!iOzgO~OZ!hO_wOh!iO~O`!jOzgO~OzgO}!lO~OzgOZoa_oahoa~OZ!oOzgO~OZ!qOzgO~OZ!rO_wOh!sO~Ob!vOc!vO}!xO!O!vO~OZ!yOzgO~OZ!zOzgO~Ob!vOc!vO}!}O!O!vO~O\",\n  goto: \"&S!QPPPPPPP!R!RP!]P!fP!mPP!vPPP!X!X#QP#W#_#g#m#s#z%S%c%i%oPPPP%uPPPPPPP&OWROS`bTl^nU`TasTl^nZ^T^ans_xiuvy!V!W!gQ!m![S!u!j!kR!{!tQp^R!SnZ_T^ansUSO`bR[SQVPRcVQYQReYSaTsRraQh]jthv!P!T!V!Z!]!b!e!k!n!p!tQviQ!PkQ!ToQ!VuQ!ZwQ!]xQ!b!QQ!e!UQ!k![Q!n!aQ!p!dR!t!jQyiS!WuvU!^y!W!gR!g!VQ!w!lR!|!wQn^R!RnQ}jR!_}QTOQq`RsbTm^n\",\n  nodeNames: \"âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Comment ProcessingInst DoctypeDecl Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue EntityReference CharacterReference Text Cdata MismatchedCloseTag CloseTag SelfCloseEndTag SelfClosingTag\",\n  maxTerm: 49,\n  context: elementContext,\n  nodeProps: [[NodeProp.closedBy, 1, \"SelfCloseEndTag EndTag\", 12, \"CloseTag MissingCloseTag\"], [NodeProp.openedBy, 11, \"StartTag StartCloseTag\", 23, \"OpenTag\", 24, \"StartTag\"]],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"Az~R!WOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs&tsv$kvw'Uw}$k}!O(q!O!P$k!P!Q*n!Q![$k![!]+z!]!^$k!^!_/s!_!`=i!`!a>U!a!b>q!b!c$k!c!}+z!}#P$k#P#Q?}#Q#R$k#R#S+z#S#T$k#T#o+z#o%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U$k4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$kY$rUdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$kQ%ZRdQOv%Uw!^%U!_~%UW%iR!OWOr%dsv%dw~%d_%{]dQ!OWzTOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs%Usv$kw!^$k!^!_%d!_~$kZ&{R}XdQOv%Uw!^%U!_~%U~'XTOp'hqs'hst(Pt!]'h!^~'h~'kTOp'hqs'ht!]'h!]!^'z!^~'h~(POb~~(SROp(]q!](]!^~(]~(`SOp(]q!](]!]!^(l!^~(]~(qOc~Z(xWdQ!OWOr$krs%Usv$kw}$k}!O)b!O!^$k!^!_%d!_~$kZ)iWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a*R!a~$kZ*[UxPdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$k^*uWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a+_!a~$k^+hUhSdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$k_,V}_S]PdQ!OWOr$krs%Usv$kw}$k}!O+z!O!P+z!P!Q$k!Q![+z![!]+z!]!^$k!^!_%d!_!c$k!c!}+z!}#R$k#R#S+z#S#T$k#T#o+z#o$}$k$}%O+z%O%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U+z4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Je$k$Je$Jg+z$Jg$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$k_/ZWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_;=`$k;=`<%l+z<%l~$kZ/xU!OWOq%dqr0[sv%dw!a%d!a!b=X!b~%dZ0aZ!OWOr%dsv%dw}%d}!O1S!O!f%d!f!g1x!g!}%d!}#O5s#O#W%d#W#X:k#X~%dZ1XT!OWOr%dsv%dw}%d}!O1h!O~%dZ1oRyR!OWOr%dsv%dw~%dX1}T!OWOr%dsv%dw!q%d!q!r2^!r~%dX2cT!OWOr%dsv%dw!e%d!e!f2r!f~%dX2wT!OWOr%dsv%dw!v%d!v!w3W!w~%dX3]T!OWOr%dsv%dw!{%d!{!|3l!|~%dX3qT!OWOr%dsv%dw!r%d!r!s4Q!s~%dX4VT!OWOr%dsv%dw!g%d!g!h4f!h~%dX4kV!OWOr4frs5Qsv4fvw5Qw!`4f!`!a5c!a~4fP5TRO!`5Q!`!a5^!a~5QP5cOXPX5jRXP!OWOr%dsv%dw~%dY5xV!OWOr%dsv%dw!e%d!e!f6_!f#V%d#V#W8w#W~%dY6dT!OWOr%dsv%dw!f%d!f!g6s!g~%dY6xT!OWOr%dsv%dw!c%d!c!d7X!d~%dY7^T!OWOr%dsv%dw!v%d!v!w7m!w~%dY7rT!OWOr%dsv%dw!c%d!c!d8R!d~%dY8WT!OWOr%dsv%dw!}%d!}#O8g#O~%dY8nR!OW!RQOr%dsv%dw~%dY8|T!OWOr%dsv%dw#W%d#W#X9]#X~%dY9bT!OWOr%dsv%dw#T%d#T#U9q#U~%dY9vT!OWOr%dsv%dw#h%d#h#i:V#i~%dY:[T!OWOr%dsv%dw#T%d#T#U8R#U~%dX:pT!OWOr%dsv%dw#c%d#c#d;P#d~%dX;UT!OWOr%dsv%dw#V%d#V#W;e#W~%dX;jT!OWOr%dsv%dw#h%d#h#i;y#i~%dX<OT!OWOr%dsv%dw#m%d#m#n<_#n~%dX<dT!OWOr%dsv%dw#d%d#d#e<s#e~%dX<xT!OWOr%dsv%dw#X%d#X#Y4f#Y~%dZ=`R|R!OWOr%dsv%dw~%dZ=rU`PdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$k_>_UZTdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$kZ>xWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a?b!a~$kZ?kU{PdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$kZ@UWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_#P$k#P#Q@n#Q~$kZ@uWdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!aA_!a~$kZAhU!QPdQ!OWOr$krs%Usv$kw!^$k!^!_%d!_~$k\",\n  tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],\n  topRules: {\n    \"Document\": [0, 6]\n  },\n  tokenPrec: 0\n});\nexport { parser };","import _classCallCheck from \"/Users/msfew/markd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nfunction tagName(doc, tag) {\n  var name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction elementName(doc, tree) {\n  var tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\n\nfunction attrName(doc, tag, pos) {\n  var attr = tag && tag.getChildren(\"Attribute\").find(function (a) {\n    return a.from <= pos && a.to >= pos;\n  });\n  var name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction findParentElement(tree) {\n  for (var cur = tree && tree.parent; cur; cur = cur.parent) {\n    if (cur.name == \"Element\") return cur;\n  }\n\n  return null;\n}\n\nfunction findLocation(state, pos) {\n  var _a;\n\n  var at = syntaxTree(state).resolveInner(pos, -1),\n      inTag = null;\n\n  for (var cur = at; !inTag && cur.parent; cur = cur.parent) {\n    if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n  }\n\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    var elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    var before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) {\n    at = at.parent;\n  }\n\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\n\nvar Element = function Element(spec, attrs, attrValues) {\n  _classCallCheck(this, Element);\n\n  this.attrs = attrs;\n  this.attrValues = attrValues;\n  this.children = [];\n  this.name = spec.name;\n  this.completion = Object.assign(Object.assign({\n    type: \"type\"\n  }, spec.completion || {}), {\n    label: this.name\n  });\n  this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"<\" + this.name\n  });\n  this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"</\" + this.name + \">\",\n    boost: 2\n  });\n  this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: this.name + \">\"\n  });\n  this.text = spec.textContent ? spec.textContent.map(function (s) {\n    return {\n      label: s,\n      type: \"text\"\n    };\n  }) : [];\n};\n\nvar Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\n\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\n\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: \"\\\"\".concat(spec, \"\\\"\"),\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: \"\\\"\".concat(spec.label, \"\\\"\")\n  });\n}\n\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  var allAttrs = [],\n      globalAttrs = [];\n  var attrValues = Object.create(null);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = attrSpecs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _s = _step.value;\n      var completion = attrCompletion(_s);\n      allAttrs.push(completion);\n      if (_s.global) globalAttrs.push(completion);\n      if (_s.values) attrValues[_s.name] = _s.values.map(valueCompletion);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var allElements = [],\n      topElements = [];\n  var byName = Object.create(null);\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var s = _step2.value;\n      var attrs = globalAttrs,\n          attrVals = attrValues;\n      if (s.attributes) attrs = attrs.concat(s.attributes.map(function (s) {\n        if (typeof s == \"string\") return allAttrs.find(function (a) {\n          return a.label == s;\n        }) || {\n          label: s,\n          type: \"property\"\n        };\n\n        if (s.values) {\n          if (attrVals == attrValues) attrVals = Object.create(attrVals);\n          attrVals[s.name] = s.values.map(valueCompletion);\n        }\n\n        return attrCompletion(s);\n      }));\n      var elt = new Element(s, attrs, attrVals);\n      byName[elt.name] = elt;\n      allElements.push(elt);\n      if (s.top) topElements.push(elt);\n    };\n\n    for (var _iterator2 = eltSpecs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  if (!topElements.length) topElements = allElements;\n\n  for (var i = 0; i < allElements.length; i++) {\n    var s = eltSpecs[i],\n        elt = allElements[i];\n\n    if (s.children) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = s.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var ch = _step3.value;\n          if (byName[ch]) elt.children.push(byName[ch]);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    } else {\n      elt.children = allElements;\n    }\n  }\n\n  return function (cx) {\n    var _a;\n\n    var doc = cx.state.doc,\n        loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    var type = loc.type,\n        from = loc.from,\n        context = loc.context;\n\n    if (type == \"openTag\") {\n      var children = topElements;\n      var parentName = elementName(doc, context);\n\n      if (parentName) {\n        var parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n\n      return {\n        from: from,\n        options: children.map(function (ch) {\n          return ch.completion;\n        }),\n        span: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      var _parentName = elementName(doc, context);\n\n      return _parentName ? {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[_parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: _parentName + \">\",\n          type: \"type\"\n        }],\n        span: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      var _parent = byName[tagName(doc, context)];\n      return {\n        from: from,\n        options: (_parent === null || _parent === void 0 ? void 0 : _parent.attrs) || globalAttrs,\n        span: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      var attr = attrName(doc, context, from);\n      if (!attr) return null;\n      var _parent2 = byName[tagName(doc, context)];\n      var values = ((_parent2 === null || _parent2 === void 0 ? void 0 : _parent2.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        span: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      var _parentName2 = elementName(doc, context),\n          _parent3 = byName[_parentName2];\n\n      var closing = [],\n          last = context && context.lastChild;\n      if (_parentName2 && (!last || last.name != \"CloseTag\" || tagName(doc, last) != _parentName2)) closing.push(_parent3 ? _parent3.closeCompletion : {\n        label: \"</\" + _parentName2 + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      var options = closing.concat(((_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.children) || (context ? allElements : topElements)).map(function (e) {\n        return e.openCompletion;\n      }));\n\n      if (context && (_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.text.length)) {\n        var openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(_parent3.text);\n      }\n\n      return {\n        from: from,\n        options: options,\n        span: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\n\n\nvar xmlLanguage =\n/*@__PURE__*/\nLRLanguage.define({\n  parser:\n  /*@__PURE__*/\n  parser.configure({\n    props: [\n    /*@__PURE__*/\n    indentNodeProp.add({\n      Element: function Element(context) {\n        var closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"OpenTag CloseTag SelfClosingTag\": function OpenTagCloseTagSelfClosingTag(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }),\n    /*@__PURE__*/\n    foldNodeProp.add({\n      Element: function Element(subtree) {\n        var first = subtree.firstChild,\n            last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n    }),\n    /*@__PURE__*/\n    styleTags({\n      AttributeValue: tags.string,\n      Text: tags.content,\n      \"StartTag StartCloseTag EndTag SelfCloseEndTag\": tags.angleBracket,\n      TagName: tags.tagName,\n      \"MismatchedCloseTag/Tagname\": [tags.tagName, tags.invalid],\n      AttributeName: tags.propertyName,\n      UnquotedAttributeValue: tags.string,\n      Is: tags.definitionOperator,\n      \"EntityReference CharacterReference\": tags.character,\n      Comment: tags.blockComment,\n      ProcessingInst: tags.processingInstruction,\n      DoctypeDecl: tags.documentMeta,\n      Cdata:\n      /*@__PURE__*/\n      tags.special(tags.string)\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\n\nfunction xml() {\n  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };"],"sourceRoot":""}