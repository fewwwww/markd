{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/haxe.js"],"names":["kw","type","style","content","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","next","escaped","ret","tp","cont","haxeTokenBase","ch","quote","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","imported","typename","charAt","len","importedtypes","length","i","registerimport","importname","cx","t","marked","cc","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","lexical","lex","poplex","expect","wanted","statement","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","hasOwnProperty","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","haxe","startState","indentUnit","token","sol","indentation","eatSpace","pop","parseHaxe","indent","textAfter","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","open","close","hxml","define","inString","peek","skipTo"],"mappings":"mGACA,SAASA,EAAGC,GACV,MAAO,CACLA,KAAMA,EACNC,MAAO,WAJX,mFAQA,IA2EUC,EA3ENC,EAAIJ,EAAG,aACPK,EAAIL,EAAG,aACPM,EAAIN,EAAG,aACPO,EAAWP,EAAG,YACdQ,EAAO,CACTP,KAAM,OACNC,MAAO,QAELO,EAAY,CACdR,KAAM,YACNC,MAAO,aAELD,EAAOD,EAAG,WACVU,EAAW,CACb,GAAMN,EACN,MAASA,EACT,KAAQC,EACR,GAAMA,EACN,IAAOA,EACP,OAAUC,EACV,MAASA,EACT,SAAYA,EACZ,IAAOA,EACP,MAASA,EACT,IAAON,EAAG,OACV,OAAUS,EACV,OAAUA,EACV,MAAST,EAAG,UACZ,OAAUS,EACV,QAAWA,EACX,KAAQT,EAAG,QACX,OAAUA,EAAG,UACb,MAASA,EAAG,SACZ,SAAYA,EAAG,YACf,MAASA,EAAG,SACZ,QAAWA,EAAG,WACd,SAAYA,EAAG,MACf,IAAOA,EAAG,OACV,OAAUA,EAAG,UACb,KAAQA,EAAG,QACX,QAAWA,EAAG,WACd,GAAMO,EACN,MAASP,EAAG,mBACZ,MAASA,EAAG,SACZ,MAASC,EACT,SAAYA,EACZ,KAAQA,EACR,UAAaA,EACb,QAAWA,EACX,QAAWA,EACX,WAAcA,EACd,QAAWA,EACX,KAAQO,EACR,MAASA,EACT,KAAQA,GAENG,EAAiB,iBAErB,SAASC,EAAMC,EAAQC,EAAOC,GAE5B,OADAD,EAAME,SAAWD,EACVA,EAAEF,EAAQC,GAGnB,SAASG,EAAYJ,EAAQK,GAI3B,IAHA,IACIC,EADAC,GAAU,EAGmB,OAAzBD,EAAON,EAAOM,SAAiB,CACrC,GAAIA,GAAQD,IAAQE,EAAS,OAAO,EACpCA,GAAWA,GAAmB,MAARD,GAQ1B,SAASE,EAAIC,EAAIpB,EAAOqB,GAGtB,OAFAtB,EAAOqB,EACPnB,EAAUoB,EACHrB,EAGT,SAASsB,EAAcX,EAAQC,GAC7B,IAAIW,EAAKZ,EAAOM,OAEhB,GAAU,KAANM,GAAmB,KAANA,EACf,OAAOb,EAAMC,EAAQC,GAiDAY,EAjDuBD,EAkDvC,SAAUZ,EAAQC,GAEvB,OADIG,EAAYJ,EAAQa,KAAQZ,EAAME,SAAWQ,GAC1CH,EAAI,SAAU,aAnDhB,GAAI,qBAAqBM,KAAKF,GACnC,OAAOJ,EAAII,GACN,GAAU,KAANA,GAAaZ,EAAOe,IAAI,MAEjC,OADAf,EAAOgB,SAAS,YACTR,EAAI,SAAU,UAChB,GAAI,KAAKM,KAAKF,IAAa,KAANA,GAAaZ,EAAOe,IAAI,MAElD,OADAf,EAAOiB,MAAM,0CACNT,EAAI,SAAU,UAChB,GAAIP,EAAMiB,WAAmB,KAANN,GAAaZ,EAAOe,IAAI,MAGpD,OAFAX,EAAYJ,EAAQ,KACpBA,EAAOgB,SAAS,WACTR,EAAI,SAAU,kBAChB,GAAU,KAANI,EACT,OAAIZ,EAAOe,IAAI,KACNhB,EAAMC,EAAQC,EAAOkB,GACnBnB,EAAOe,IAAI,MACpBf,EAAOoB,YACAZ,EAAI,UAAW,aAEtBR,EAAOgB,SAASlB,GACTU,EAAI,WAAY,KAAMR,EAAOqB,YAEjC,GAAU,KAANT,EAET,OADAZ,EAAOoB,YACAZ,EAAI,cAAe,QACrB,GAAU,KAANI,EAGT,OAFAZ,EAAOe,IAAI,KACXf,EAAOgB,SAAS,SACTR,EAAI,WAAY,QAClB,GAAIV,EAAegB,KAAKF,GAE7B,OADAZ,EAAOgB,SAASlB,GACTU,EAAI,WAAY,KAAMR,EAAOqB,WAIpC,GAAI,QAAQP,KAAKF,GAGf,OAFAZ,EAAOgB,SAAS,WAETR,EAAI,OAAQ,OADnBc,EAAOtB,EAAOqB,WAGdrB,EAAOgB,SAAS,SAChB,IAOmBH,EAPfS,EAAOtB,EAAOqB,UACdE,EAAQ1B,EAAS2B,qBAAqBF,IAASzB,EAASyB,GAC5D,OAAOC,GAAStB,EAAMwB,UAAYjB,EAAIe,EAAMnC,KAAMmC,EAAMlC,MAAOiC,GAAQd,EAAI,WAAY,WAAYc,GAYzG,SAASH,EAAiBnB,EAAQC,GAIhC,IAHA,IACIW,EADAc,GAAW,EAGRd,EAAKZ,EAAOM,QAAQ,CACzB,GAAU,KAANM,GAAac,EAAU,CACzBzB,EAAME,SAAWQ,EACjB,MAGFe,EAAiB,KAANd,EAGb,OAAOJ,EAAI,UAAW,WAIxB,IAAImB,EAAc,CAChB,MAAQ,EACR,QAAU,EACV,UAAY,EACZ,QAAU,EACV,QAAU,GAGZ,SAASC,EAAYC,EAAUC,EAAQ1C,EAAM2C,EAAOC,EAAMC,GACxDC,KAAKL,SAAWA,EAChBK,KAAKJ,OAASA,EACdI,KAAK9C,KAAOA,EACZ8C,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,EACC,MAATF,IAAeG,KAAKH,MAAQA,GAGlC,SAASI,EAAQlC,EAAOmC,GACtB,IAAK,IAAIC,EAAIpC,EAAMqC,UAAWD,EAAGA,EAAIA,EAAE/B,KACrC,GAAI+B,EAAEE,MAAQH,EAAS,OAAO,EA6BlC,SAASI,EAASvC,EAAOwC,GACvB,GAAI,QAAQ3B,KAAK2B,EAASC,OAAO,IAAK,OAAO,EAG7C,IAFA,IAAIC,EAAM1C,EAAM2C,cAAcC,OAErBC,EAAI,EAAGA,EAAIH,EAAKG,IACvB,GAAI7C,EAAM2C,cAAcE,IAAML,EAAU,OAAO,EAInD,SAASM,EAAeC,GAGtB,IAFA,IAAI/C,EAAQgD,EAAGhD,MAENiD,EAAIjD,EAAM2C,cAAeM,EAAGA,EAAIA,EAAE5C,KACzC,GAAI4C,EAAEX,MAAQS,EAAY,OAG5B/C,EAAM2C,cAAgB,CACpBL,KAAMS,EACN1C,KAAML,EAAM2C,eAKhB,IAAIK,EAAK,CACPhD,MAAO,KACP6B,OAAQ,KACRqB,OAAQ,KACRC,GAAI,MAGN,SAASC,IACP,IAAK,IAAIP,EAAIQ,UAAUT,OAAS,EAAGC,GAAK,EAAGA,IACzCG,EAAGG,GAAGG,KAAKD,UAAUR,IAIzB,SAASpC,IAEP,OADA2C,EAAKG,MAAM,KAAMF,YACV,EAGT,SAASG,EAAOlB,EAAMmB,GACpB,IAAK,IAAIrB,EAAIqB,EAAMrB,EAAGA,EAAIA,EAAE/B,KAC1B,GAAI+B,EAAEE,MAAQA,EAAM,OAAO,EAG7B,OAAO,EAGT,SAASoB,EAASvB,GAChB,IAAInC,EAAQgD,EAAGhD,MAEf,GAAIA,EAAM2D,QAAS,CAEjB,GADAX,EAAGE,OAAS,MACRM,EAAOrB,EAASnC,EAAMqC,WAAY,OACtCrC,EAAMqC,UAAY,CAChBC,KAAMH,EACN9B,KAAML,EAAMqC,gBAET,GAAIrC,EAAM4D,WAAY,CAC3B,GAAIJ,EAAOrB,EAASnC,EAAM4D,YAAa,OACvC5D,EAAM4D,WAAa,CACjBtB,KAAMH,EACN9B,KAAML,EAAM4D,aAMlB,IAAIC,EAAc,CAChBvB,KAAM,OACNjC,KAAM,MAGR,SAASyD,IACFd,EAAGhD,MAAM2D,UAASX,EAAGhD,MAAMqC,UAAYwB,GAC5Cb,EAAGhD,MAAM2D,QAAU,CACjB5B,KAAMiB,EAAGhD,MAAM2D,QACfI,KAAMf,EAAGhD,MAAMqC,WAInB,SAAS2B,IACPhB,EAAGhD,MAAMqC,UAAYW,EAAGhD,MAAM2D,QAAQI,KACtCf,EAAGhD,MAAM2D,QAAUX,EAAGhD,MAAM2D,QAAQ5B,KAKtC,SAASkC,EAAQ9E,EAAM6C,GACrB,IAAIkC,EAAS,WACX,IAAIlE,EAAQgD,EAAGhD,MACfA,EAAMmE,QAAU,IAAIxC,EAAY3B,EAAM4B,SAAUoB,EAAGjD,OAAO8B,SAAU1C,EAAM,KAAMa,EAAMmE,QAASnC,IAIjG,OADAkC,EAAOE,KAAM,EACNF,EAGT,SAASG,IACP,IAAIrE,EAAQgD,EAAGhD,MAEXA,EAAMmE,QAAQpC,OACU,KAAtB/B,EAAMmE,QAAQhF,OAAaa,EAAM4B,SAAW5B,EAAMmE,QAAQvC,UAC9D5B,EAAMmE,QAAUnE,EAAMmE,QAAQpC,MAMlC,SAASuC,EAAOC,GAKd,OAJA,SAAStE,EAAEd,GACT,OAAIA,GAAQoF,EAAe9D,IAA0B,KAAV8D,EAAsBnB,IAAmB3C,EAAKR,IAM7F,SAASuE,EAAUrF,GACjB,MAAY,KAARA,EAAoBsB,EAAKgE,GACjB,OAARtF,EAAsBsB,EAAKwD,EAAQ,UAAWS,EAASJ,EAAO,KAAMD,GAC5D,aAARlF,EAA4BsB,EAAKwD,EAAQ,QAASU,EAAYH,EAAWH,GACjE,aAARlF,EAA4BsB,EAAKwD,EAAQ,QAASO,EAAWH,GACrD,KAARlF,EAAoBsB,EAAKwD,EAAQ,KAAMH,EAAac,EAAOP,EAAQL,GAC3D,KAAR7E,EAAoBsB,IACZ,aAARtB,EAA4BsB,EAAKoE,GACzB,YAAR1F,EAA2BsB,EAAKqE,GACxB,OAAR3F,EAAsBsB,EAAKwD,EAAQ,QAASK,EAAO,KAAML,EAAQ,KAAMc,EAAUT,EAAO,KAAMD,EAAQG,EAAWH,GACzG,YAARlF,EAA2BsB,EAAKwD,EAAQ,QAASe,GACzC,UAAR7F,EAAyBsB,EAAKwD,EAAQ,QAASU,EAAYV,EAAQ,IAAK,UAAWK,EAAO,KAAMM,EAAOP,EAAQA,GACvG,QAARlF,EAAuBsB,EAAKkE,EAAYL,EAAO,MACvC,WAARnF,EAA0BsB,EAAK6D,EAAO,MAC9B,SAARnF,EAAwBsB,EAAKwD,EAAQ,QAASH,EAAaQ,EAAO,KAAMW,GAAQX,EAAO,KAAME,EAAWH,EAAQL,GACxG,UAAR7E,EAAyBsB,EAAKyE,EAAWZ,EAAO,MACxC,WAARnF,EAA0BsB,EAAK0E,GAC5B/B,EAAKa,EAAQ,QAASU,EAAYL,EAAO,KAAMD,GAGxD,SAASM,EAAWxF,GAClB,OAAIuC,EAAY0D,eAAejG,GAAcsB,EAAK4E,GACtC,QAARlG,EAAuBsB,EAAK4E,GACpB,YAARlG,EAA2BsB,EAAKqE,GACxB,aAAR3F,EAA4BsB,EAAK6E,GACzB,KAARnG,EAAoBsB,EAAKwD,EAAQ,KAAMqB,EAAiBhB,EAAO,KAAMD,EAAQgB,GACrE,YAARlG,EAA2BsB,EAAKkE,GACxB,KAARxF,EAAoBsB,EAAKwD,EAAQ,KAAMsB,EAASD,EAAiB,KAAMjB,EAAQgB,GACvE,KAARlG,EAAoBsB,EAAKwD,EAAQ,KAAMsB,EAASC,EAAS,KAAMnB,EAAQgB,GACpE5E,IAGT,SAAS6E,EAAgBnG,GACvB,OAAIA,EAAK6B,MAAM,cAAsBoC,IAC9BA,EAAKuB,GAGd,SAASU,EAAclG,EAAMsG,GAC3B,MAAY,YAARtG,GAAsB,UAAU0B,KAAK4E,GAAehF,EAAK4E,GACjD,YAARlG,GAA8B,KAARA,EAAoBsB,EAAKkE,GACvC,KAARxF,EACQ,KAARA,EAAoBsB,EAAKwD,EAAQ,KAAMsB,EAASZ,EAAY,KAAMN,EAAQgB,GAClE,KAARlG,EAAoBsB,EAAKiF,EAAUL,GAC3B,KAARlG,EAAoBsB,EAAKwD,EAAQ,KAAMU,EAAYL,EAAO,KAAMD,EAAQgB,QAA5E,OAHA,EAMF,SAASR,EAAe1F,GACtB,MAAY,aAARA,EAA4BsB,EAAKoE,GACzB,YAAR1F,EAA2BsB,EAAKqE,GACxB,OAAR3F,EAAsBsB,EAAKiE,QAA/B,EAGF,SAASD,EAAQtF,GACf,MAAY,KAARA,EAAoBsB,EAAKgE,GACjB,YAARtF,EAA2BsB,EAAKgE,GACxB,KAARtF,EAAoBsB,EAAKwD,EAAQ,KAAMsB,EAASI,EAAU,KAAMtB,EAAQG,QAA5E,EAGF,SAASmB,EAASxG,GAChB,GAAY,YAARA,EAAoB,OAAOsB,IAGjC,SAASyE,EAAU/F,EAAMsG,GACvB,MAAY,YAARtG,GAAsB,QAAQ0B,KAAK4E,EAAMhD,OAAO,KAClDK,EAAe2C,GACRhF,KACU,YAARtB,GAA8B,YAARA,GAA8B,KAARA,GAAwB,KAATsG,EAAqBhF,EAAKyE,QAAzF,EAGT,SAASC,EAAQhG,EAAMsG,GACrB,MAAY,YAARtG,GAAsB,QAAQ0B,KAAK4E,EAAMhD,OAAO,KAClDK,EAAe2C,GACRhF,KACU,QAARtB,GAAkB,QAAQ0B,KAAK4E,EAAMhD,OAAO,IAC9ChC,SADF,EAKT,SAASuE,EAAW7F,GAClB,MAAY,KAARA,EAAoBsB,EAAK4D,EAAQG,GAC9BpB,EAAKiC,EAAef,EAAO,KAAMD,GAG1C,SAASqB,EAASvG,GAChB,GAAY,YAARA,EAEF,OADA6D,EAAGE,OAAS,WACLzC,IAIX,SAAS+E,EAAQrG,GAEf,GADY,YAARA,IAAoB6D,EAAGE,OAAS,YAChCxB,EAAY0D,eAAejG,GAAO,OAAOsB,EAAK6D,EAAO,KAAMK,GAGjE,SAASY,EAASK,EAAMxF,GACtB,SAASyF,EAAQ1G,GACf,MAAY,KAARA,EAAoBsB,EAAKmF,EAAMC,GAC/B1G,GAAQiB,EAAYK,IACjBA,EAAK6D,EAAOlE,IAGrB,OAAO,SAAUjB,GACf,OAAIA,GAAQiB,EAAYK,IAAmB2C,EAAKwC,EAAMC,IAI1D,SAASjB,EAAMzF,GACb,MAAY,KAARA,EAAoBsB,IACjB2C,EAAKoB,EAAWI,GAGzB,SAASF,EAAQvF,EAAMsG,GACrB,MAAY,YAARtG,GACFuE,EAAS+B,GACFhF,EAAKqF,GAASC,IAGhBtF,IAGT,SAASsF,EAAQ5G,EAAMsG,GACrB,MAAa,KAATA,EAAqBhF,EAAKkE,EAAYoB,GAC9B,KAAR5G,EAAoBsB,EAAKiE,QAA7B,EAGF,SAASK,EAAS5F,EAAMsG,GACtB,MAAY,YAARtG,GACFuE,EAAS+B,GACFhF,EAAKuF,EAAOrB,IAEZvB,IAIX,SAAS4C,EAAMC,EAAOR,GACpB,GAAa,MAATA,EAAe,OAAOhF,IAG5B,SAASqE,EAAY3F,EAAMsG,GAEzB,MAAY,YAARtG,GAA8B,QAARA,GACxBuE,EAAS+B,GACFhF,EAAKqE,IAGD,OAATW,EAAuBhF,EAAKqE,GACpB,KAAR3F,EAAoBsB,EAAKwD,EAAQ,KAAMH,EAAayB,EAASN,GAAQ,KAAMZ,EAAQyB,GAAStB,EAAWR,QAA3G,EAGF,SAAS8B,GAAQ3G,GACf,GAAY,KAARA,EAAa,OAAOsB,EAAKyF,IAG/B,SAASA,GAAW/G,GAClB,MAAY,QAARA,EAAuBsB,IACf,YAARtB,EAA2BsB,IACnB,KAARtB,EAAoBsB,EAAKwD,EAAQ,KAAMsB,EAASY,GAAU,KAAM9B,QAApE,EAGF,SAAS8B,GAAShH,GAChB,GAAY,YAARA,EAAoB,OAAOsB,EAAKqF,IAGtC,SAASb,GAAO9F,EAAMsG,GACpB,GAAY,YAARtG,EAEF,OADAuE,EAAS+B,GACFhF,EAAKqF,IAtMhB9B,EAAWI,KAAM,EAqBjBC,EAAOD,KAAM,EAsLN,IAAIgC,GAAO,CAChBC,WAAY,SAAoBC,GAY9B,MAVY,CACVpG,SAAUQ,EACVO,WAAW,EACXO,WAAW,EACX2B,GAAI,GACJgB,QAAS,IAAIxC,GAAa2E,EAAY,EAAG,SAAS,GAClD3D,cAPiB,CAAC,MAAO,QAAS,SAAU,OAAQ,MAAO,OAAQ,UAAW,SAQ9EgB,QAAS,KACT/B,SAAU,IAId2E,MAAO,SAAexG,EAAQC,GAM5B,GALID,EAAOyG,QACJxG,EAAMmE,QAAQiB,eAAe,WAAUpF,EAAMmE,QAAQrC,OAAQ,GAClE9B,EAAM4B,SAAW7B,EAAO0G,eAGtB1G,EAAO2G,WAAY,OAAO,KAC9B,IAAItH,EAAQY,EAAME,SAASH,EAAQC,GACnC,MAAY,WAARb,EAA0BC,GAC9BY,EAAMiB,YAAuB,YAAR9B,GAA8B,aAARA,IAAuBA,EAAK6B,MAAM,kBAC7EhB,EAAMwB,UAAoB,KAARrC,EApVtB,SAAmBa,EAAOZ,EAAOD,EAAME,EAASU,GAC9C,IAAIoD,EAAKnD,EAAMmD,GAQf,IALAH,EAAGhD,MAAQA,EACXgD,EAAGjD,OAASA,EACZiD,EAAGE,OAAS,KAAMF,EAAGG,GAAKA,EACrBnD,EAAMmE,QAAQiB,eAAe,WAAUpF,EAAMmE,QAAQrC,OAAQ,KAErD,CAGX,IAFiBqB,EAAGP,OAASO,EAAGwD,MAAQnC,GAEzBrF,EAAME,GAAU,CAC7B,KAAO8D,EAAGP,QAAUO,EAAGA,EAAGP,OAAS,GAAGwB,KACpCjB,EAAGwD,KAAHxD,GAGF,OAAIH,EAAGE,OAAeF,EAAGE,OACb,YAAR/D,GAAsB+C,EAAQlC,EAAOX,GAAiB,qBAC9C,YAARF,GAAsBoD,EAASvC,EAAOX,GAAiB,uBACpDD,IAiUFwH,CAAU5G,EAAOZ,EAAOD,EAAME,EAASU,KAEhD8G,OAAQ,SAAgB7G,EAAO8G,EAAW9D,GACxC,GAAIhD,EAAME,UAAYQ,EAAe,OAAO,EAC5C,IAAIqG,EAAYD,GAAaA,EAAUrE,OAAO,GAC1C0B,EAAUnE,EAAMmE,QACA,QAAhBA,EAAQhF,MAA+B,KAAb4H,IAAkB5C,EAAUA,EAAQpC,MAClE,IAAI5C,EAAOgF,EAAQhF,KACf6H,EAAUD,GAAa5H,EAC3B,MAAY,UAARA,EAAyBgF,EAAQvC,SAAW,EAAmB,QAARzC,GAA+B,KAAb4H,EAAyB5C,EAAQvC,SAA0B,QAARzC,GAA0B,QAARA,EAAuBgF,EAAQvC,SAAWoB,EAAGiE,KAA8B,UAAhB9C,EAAQnC,MAAqBgF,EAA4G7C,EAAQrC,MAAcqC,EAAQtC,QAAUmF,EAAU,EAAI,GAAe7C,EAAQvC,UAAYoF,EAAU,EAAIhE,EAAGiE,MAAtM9C,EAAQvC,UAAY,sBAAsBf,KAAKiG,GAAa9D,EAAGiE,KAAO,EAAIjE,EAAGiE,OAEzUC,aAAc,CACZC,cAAe,YACfC,cAAe,CACbC,KAAM,KACNzC,MAAO,CACL0C,KAAM,KACNC,MAAO,SAKJC,GAAO,CAChBnB,WAAY,WACV,MAAO,CACLoB,QAAQ,EACRC,UAAU,IAGdnB,MAAO,SAAexG,EAAQC,GAC5B,IAAIW,EAAKZ,EAAO4H,OACZnB,EAAMzG,EAAOyG,MAEjB,GAAU,KAAN7F,EAEF,OADAZ,EAAOoB,YACA,UAGT,GAAIqF,GAAa,KAAN7F,EAAW,CACpB,IAAIvB,EAAQ,aAeZ,OAdAW,EAAOe,IAAI,KAEU,KAAjBf,EAAO4H,SACT5H,EAAOe,IAAI,KACX1B,EAAQ,aAGW,KAAjBW,EAAO4H,SACT5H,EAAOe,IAAI,OACX1B,EAAQ,YACRY,EAAMyH,QAAS,GAGjB1H,EAAOgB,SAAS,UACT3B,EAGLuB,EAAKZ,EAAO4H,OAOhB,OALsB,GAAlB3H,EAAM0H,UAA2B,KAAN/G,IAC7BX,EAAM0H,UAAW,EACjB3H,EAAOM,QAGa,GAAlBL,EAAM0H,UACJ3H,EAAO6H,OAAO,MAChB7H,EAAOoB,YAGY,KAAjBpB,EAAO4H,SACT5H,EAAOM,OACPL,EAAM0H,UAAW,GAGZ,WAGT3H,EAAOM,OACA,OAET6G,aAAc,CACZE,cAAe,CACbC,KAAM","file":"static/js/7.a09495ec.chunk.js","sourcesContent":["// Tokenizer\nfunction kw(type) {\n  return {\n    type: type,\n    style: \"keyword\"\n  };\n}\n\nvar A = kw(\"keyword a\"),\n    B = kw(\"keyword b\"),\n    C = kw(\"keyword c\");\nvar operator = kw(\"operator\"),\n    atom = {\n  type: \"atom\",\n  style: \"atom\"\n},\n    attribute = {\n  type: \"attribute\",\n  style: \"attribute\"\n};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A,\n  \"while\": A,\n  \"else\": B,\n  \"do\": B,\n  \"try\": B,\n  \"return\": C,\n  \"break\": C,\n  \"continue\": C,\n  \"new\": C,\n  \"throw\": C,\n  \"var\": kw(\"var\"),\n  \"inline\": attribute,\n  \"static\": attribute,\n  \"using\": kw(\"import\"),\n  \"public\": attribute,\n  \"private\": attribute,\n  \"cast\": kw(\"cast\"),\n  \"import\": kw(\"import\"),\n  \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"),\n  \"catch\": kw(\"catch\"),\n  \"untyped\": kw(\"untyped\"),\n  \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"),\n  \"switch\": kw(\"switch\"),\n  \"case\": kw(\"case\"),\n  \"default\": kw(\"default\"),\n  \"in\": operator,\n  \"never\": kw(\"property_access\"),\n  \"trace\": kw(\"trace\"),\n  \"class\": type,\n  \"abstract\": type,\n  \"enum\": type,\n  \"interface\": type,\n  \"typedef\": type,\n  \"extends\": type,\n  \"implements\": type,\n  \"dynamic\": type,\n  \"true\": atom,\n  \"false\": atom,\n  \"null\": atom\n};\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false,\n      next;\n\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped) return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n} // Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\n\n\nvar type, content;\n\nfunction ret(tp, style, cont) {\n  type = tp;\n  content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret(\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n\n    if (/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(),\n          known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function (stream, state) {\n    if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return ret(\"comment\", \"comment\");\n} // Parser\n\n\nvar atomicTypes = {\n  \"atom\": true,\n  \"number\": true,\n  \"variable\": true,\n  \"string\": true,\n  \"regexp\": true\n};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next) {\n    if (v.name == varname) return true;\n  }\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc; // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n\n  cx.state = state;\n  cx.stream = stream;\n  cx.marked = null, cx.cc = cc;\n  if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n  while (true) {\n    var combinator = cc.length ? cc.pop() : statement;\n\n    if (combinator(type, content)) {\n      while (cc.length && cc[cc.length - 1].lex) {\n        cc.pop()();\n      }\n\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0))) return false;\n  var len = state.importedtypes.length;\n\n  for (var i = 0; i < len; i++) {\n    if (state.importedtypes[i] == typename) return true;\n  }\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n\n  for (var t = state.importedtypes; t; t = t.next) {\n    if (t.name == importname) return;\n  }\n\n  state.importedtypes = {\n    name: importname,\n    next: state.importedtypes\n  };\n} // Combinator utils\n\n\nvar cx = {\n  state: null,\n  column: null,\n  marked: null,\n  cc: null\n};\n\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) {\n    cx.cc.push(arguments[i]);\n  }\n}\n\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\n\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next) {\n    if (v.name == name) return true;\n  }\n\n  return false;\n}\n\nfunction register(varname) {\n  var state = cx.state;\n\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {\n      name: varname,\n      next: state.localVars\n    };\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {\n      name: varname,\n      next: state.globalVars\n    };\n  }\n} // Combinators\n\n\nvar defaultVars = {\n  name: \"this\",\n  next: null\n};\n\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {\n    prev: cx.state.context,\n    vars: cx.state.localVars\n  };\n}\n\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\n\npopcontext.lex = true;\n\nfunction pushlex(type, info) {\n  var result = function result() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n\n  result.lex = true;\n  return result;\n}\n\nfunction poplex() {\n  var state = cx.state;\n\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\n\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n  }\n\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\n\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\") return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\n\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if (type == \":\") return cont(metadef);\n  if (type == \"variable\") return cont(metadef);\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\n\nfunction metaargs(type) {\n  if (type == \"variable\") return cont();\n}\n\nfunction importdef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n    return cont();\n  }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\n\nfunction property(type) {\n  if (type == \"variable\") {\n    cx.marked = \"property\";\n    return cont();\n  }\n}\n\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\n\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n\n  return function (type) {\n    if (type == end) return cont();else return pass(what, proceed);\n  };\n}\n\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\n\nfunction vardef1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse, vardef2);\n  }\n\n  return cont();\n}\n\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\n\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression);\n  } else {\n    return pass();\n  }\n}\n\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\n\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {\n    register(value);\n    return cont(functiondef);\n  }\n\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\n\nfunction typeuse(type) {\n  if (type == \":\") return cont(typestring);\n}\n\nfunction typestring(type) {\n  if (type == \"type\") return cont();\n  if (type == \"variable\") return cont();\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\n\nfunction typeprop(type) {\n  if (type == \"variable\") return cont(typeuse);\n}\n\nfunction funarg(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse);\n  }\n} // Interface\n\n\nexport var haxe = {\n  startState: function startState(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n        lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type,\n        closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};\nexport var hxml = {\n  startState: function startState() {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function token(stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol(); ///* comments */\n\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {} else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};"],"sourceRoot":""}