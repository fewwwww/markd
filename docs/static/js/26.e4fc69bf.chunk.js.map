{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/asn1.js"],"names":["words","str","obj","split","i","length","defaults","keywords","cmipVerbs","compareTypes","status","tags","storage","modifier","accessTypes","multiLineStrings","asn1","parserConfig","curPunc","indentStatements","isOperatorChar","tokenBase","stream","state","quote","ch","next","tokenize","escaped","end","afterNext","peek","toLowerCase","test","eat","skipToEnd","eatWhile","cur","current","propertyIsEnumerable","Context","indented","column","type","align","prev","this","pushContext","col","indent","context","popContext","t","startState","startOfLine","token","ctx","sol","indentation","eatSpace","style","languageData","indentOnInput","commentTokens","line"],"mappings":"oGAAA,SAASA,EAAMC,GAIb,IAHA,IAAIC,EAAM,GACNF,EAAQC,EAAIE,MAAM,KAEbC,EAAI,EAAGA,EAAIJ,EAAMK,SAAUD,EAClCF,EAAIF,EAAMI,KAAM,EAGlB,OAAOF,EART,4CAWA,IAAII,EAAW,CACbC,SAAUP,EAAM,oXAChBQ,UAAWR,EAAM,gDACjBS,aAAcT,EAAM,iNACpBU,OAAQV,EAAM,yCACdW,KAAMX,EAAM,kEACZY,QAASZ,EAAM,oeACfa,SAAUb,EAAM,oHAChBc,YAAad,EAAM,yEACnBe,kBAAkB,GAEb,SAASC,EAAKC,GACnB,IAWIC,EAXAX,EAAWU,EAAaV,UAAYD,EAASC,SAC7CC,EAAYS,EAAaT,WAAaF,EAASE,UAC/CC,EAAeQ,EAAaR,cAAgBH,EAASG,aACrDC,EAASO,EAAaP,QAAUJ,EAASI,OACzCC,EAAOM,EAAaN,MAAQL,EAASK,KACrCC,EAAUK,EAAaL,SAAWN,EAASM,QAC3CC,EAAWI,EAAaJ,UAAYP,EAASO,SAC7CC,EAAcG,EAAaH,aAAeR,EAASQ,YACnDC,EAAmBE,EAAaF,kBAAoBT,EAASS,iBAC7DI,GAAqD,IAAlCF,EAAaE,iBAChCC,EAAiB,SAGrB,SAASC,EAAUC,EAAQC,GACzB,IA0CmBC,EA1CfC,EAAKH,EAAOI,OAEhB,GAAU,KAAND,GAAmB,KAANA,EAEf,OADAF,EAAMI,UAuCWH,EAvCYC,EAwCxB,SAAUH,EAAQC,GAKvB,IAJA,IACIG,EADAE,GAAU,EAEVC,GAAM,EAEuB,OAAzBH,EAAOJ,EAAOI,SAAiB,CACrC,GAAIA,GAAQF,IAAUI,EAAS,CAC7B,IAAIE,EAAYR,EAAOS,OAEnBD,IAEe,MADjBA,EAAYA,EAAUE,gBACe,KAAbF,GAAiC,KAAbA,GAAkBR,EAAOI,QAGvEG,GAAM,EACN,MAGFD,GAAWA,GAAmB,MAARF,EAIxB,OADIG,IAASD,IAAWb,KAAmBQ,EAAMI,SAAW,MACrD,WA7DAJ,EAAMI,SAASL,EAAQC,GAGhC,GAAI,mBAAmBU,KAAKR,GAE1B,OADAP,EAAUO,EACH,cAGT,GAAU,KAANA,GACEH,EAAOY,IAAI,KAEb,OADAZ,EAAOa,YACA,UAIX,GAAI,KAAKF,KAAKR,GAEZ,OADAH,EAAOc,SAAS,UACT,SAGT,GAAIhB,EAAea,KAAKR,GAEtB,OADAH,EAAOc,SAAShB,GACT,WAGTE,EAAOc,SAAS,UAChB,IAAIC,EAAMf,EAAOgB,UACjB,OAAI/B,EAASgC,qBAAqBF,GAAa,UAC3C7B,EAAU+B,qBAAqBF,GAAa,eAC5C5B,EAAa8B,qBAAqBF,GAAa,OAC/C3B,EAAO6B,qBAAqBF,GAAa,UACzC1B,EAAK4B,qBAAqBF,GAAa,WACvCzB,EAAQ2B,qBAAqBF,GAAa,WAC1CxB,EAAS0B,qBAAqBF,GAAa,WAC3CvB,EAAYyB,qBAAqBF,GAAa,WAC3C,eA8BT,SAASG,EAAQC,EAAUC,EAAQC,EAAMC,EAAOC,GAC9CC,KAAKL,SAAWA,EAChBK,KAAKJ,OAASA,EACdI,KAAKH,KAAOA,EACZG,KAAKF,MAAQA,EACbE,KAAKD,KAAOA,EAGd,SAASE,EAAYxB,EAAOyB,EAAKL,GAC/B,IAAIM,EAAS1B,EAAMkB,SAEnB,OADIlB,EAAM2B,SAAiC,aAAtB3B,EAAM2B,QAAQP,OAAqBM,EAAS1B,EAAM2B,QAAQT,UACxElB,EAAM2B,QAAU,IAAIV,EAAQS,EAAQD,EAAKL,EAAM,KAAMpB,EAAM2B,SAGpE,SAASC,EAAW5B,GAClB,IAAI6B,EAAI7B,EAAM2B,QAAQP,KAEtB,MADS,KAALS,GAAiB,KAALA,GAAiB,KAALA,IAAU7B,EAAMkB,SAAWlB,EAAM2B,QAAQT,UAC9DlB,EAAM2B,QAAU3B,EAAM2B,QAAQL,KAIvC,MAAO,CACLQ,WAAY,WACV,MAAO,CACL1B,SAAU,KACVuB,QAAS,IAAIV,GAAS,EAAG,EAAG,OAAO,GACnCC,SAAU,EACVa,aAAa,IAGjBC,MAAO,SAAejC,EAAQC,GAC5B,IAAIiC,EAAMjC,EAAM2B,QAQhB,GANI5B,EAAOmC,QACQ,MAAbD,EAAIZ,QAAeY,EAAIZ,OAAQ,GACnCrB,EAAMkB,SAAWnB,EAAOoC,cACxBnC,EAAM+B,aAAc,GAGlBhC,EAAOqC,WAAY,OAAO,KAC9BzC,EAAU,KACV,IAAI0C,GAASrC,EAAMI,UAAYN,GAAWC,EAAQC,GAClD,GAAa,WAATqC,EAAoB,OAAOA,EAG/B,GAFiB,MAAbJ,EAAIZ,QAAeY,EAAIZ,OAAQ,GAEnB,KAAX1B,GAA6B,KAAXA,GAA6B,KAAXA,GAA+B,aAAZsC,EAAIb,KAEzD,GAAe,KAAXzB,EAAgB6B,EAAYxB,EAAOD,EAAOoB,SAAU,UAAU,GAAe,KAAXxB,EAAgB6B,EAAYxB,EAAOD,EAAOoB,SAAU,UAAU,GAAe,KAAXxB,EAAgB6B,EAAYxB,EAAOD,EAAOoB,SAAU,UAAU,GAAe,KAAXxB,EAAgB,CAC/N,KAAmB,aAAZsC,EAAIb,MACTa,EAAML,EAAW5B,GAKnB,IAFgB,KAAZiC,EAAIb,OAAaa,EAAML,EAAW5B,IAEnB,aAAZiC,EAAIb,MACTa,EAAML,EAAW5B,QAEVL,GAAWsC,EAAIb,KAAMQ,EAAW5B,GAAgBJ,KAAkC,KAAZqC,EAAIb,MAA2B,OAAZa,EAAIb,OAA6B,KAAXzB,GAA8B,aAAZsC,EAAIb,MAAkC,gBAAXzB,IAA4B6B,EAAYxB,EAAOD,EAAOoB,SAAU,kBAXrOS,EAAW5B,GAcb,OADAA,EAAM+B,aAAc,EACbM,GAETC,aAAc,CACZC,cAAe,YACfC,cAAe,CACbC,KAAM","file":"static/js/26.e4fc69bf.chunk.js","sourcesContent":["function words(str) {\n  var obj = {},\n      words = str.split(\" \");\n\n  for (var i = 0; i < words.length; ++i) {\n    obj[words[i]] = true;\n  }\n\n  return obj;\n}\n\nvar defaults = {\n  keywords: words(\"DEFINITIONS OBJECTS IF DERIVED INFORMATION ACTION\" + \" REPLY ANY NAMED CHARACTERIZED BEHAVIOUR REGISTERED\" + \" WITH AS IDENTIFIED CONSTRAINED BY PRESENT BEGIN\" + \" IMPORTS FROM UNITS SYNTAX MIN-ACCESS MAX-ACCESS\" + \" MINACCESS MAXACCESS REVISION STATUS DESCRIPTION\" + \" SEQUENCE SET COMPONENTS OF CHOICE DistinguishedName\" + \" ENUMERATED SIZE MODULE END INDEX AUGMENTS EXTENSIBILITY\" + \" IMPLIED EXPORTS\"),\n  cmipVerbs: words(\"ACTIONS ADD GET NOTIFICATIONS REPLACE REMOVE\"),\n  compareTypes: words(\"OPTIONAL DEFAULT MANAGED MODULE-TYPE MODULE_IDENTITY\" + \" MODULE-COMPLIANCE OBJECT-TYPE OBJECT-IDENTITY\" + \" OBJECT-COMPLIANCE MODE CONFIRMED CONDITIONAL\" + \" SUBORDINATE SUPERIOR CLASS TRUE FALSE NULL\" + \" TEXTUAL-CONVENTION\"),\n  status: words(\"current deprecated mandatory obsolete\"),\n  tags: words(\"APPLICATION AUTOMATIC EXPLICIT IMPLICIT PRIVATE TAGS\" + \" UNIVERSAL\"),\n  storage: words(\"BOOLEAN INTEGER OBJECT IDENTIFIER BIT OCTET STRING\" + \" UTCTime InterfaceIndex IANAifType CMIP-Attribute\" + \" REAL PACKAGE PACKAGES IpAddress PhysAddress\" + \" NetworkAddress BITS BMPString TimeStamp TimeTicks\" + \" TruthValue RowStatus DisplayString GeneralString\" + \" GraphicString IA5String NumericString\" + \" PrintableString SnmpAdminString TeletexString\" + \" UTF8String VideotexString VisibleString StringStore\" + \" ISO646String T61String UniversalString Unsigned32\" + \" Integer32 Gauge Gauge32 Counter Counter32 Counter64\"),\n  modifier: words(\"ATTRIBUTE ATTRIBUTES MANDATORY-GROUP MANDATORY-GROUPS\" + \" GROUP GROUPS ELEMENTS EQUALITY ORDERING SUBSTRINGS\" + \" DEFINED\"),\n  accessTypes: words(\"not-accessible accessible-for-notify read-only\" + \" read-create read-write\"),\n  multiLineStrings: true\n};\nexport function asn1(parserConfig) {\n  var keywords = parserConfig.keywords || defaults.keywords,\n      cmipVerbs = parserConfig.cmipVerbs || defaults.cmipVerbs,\n      compareTypes = parserConfig.compareTypes || defaults.compareTypes,\n      status = parserConfig.status || defaults.status,\n      tags = parserConfig.tags || defaults.tags,\n      storage = parserConfig.storage || defaults.storage,\n      modifier = parserConfig.modifier || defaults.modifier,\n      accessTypes = parserConfig.accessTypes || defaults.accessTypes,\n      multiLineStrings = parserConfig.multiLineStrings || defaults.multiLineStrings,\n      indentStatements = parserConfig.indentStatements !== false;\n  var isOperatorChar = /[\\|\\^]/;\n  var curPunc;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n\n    if (/[\\[\\]\\(\\){}:=,;]/.test(ch)) {\n      curPunc = ch;\n      return \"punctuation\";\n    }\n\n    if (ch == \"-\") {\n      if (stream.eat(\"-\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w\\.]/);\n      return \"number\";\n    }\n\n    if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return \"operator\";\n    }\n\n    stream.eatWhile(/[\\w\\-]/);\n    var cur = stream.current();\n    if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n    if (cmipVerbs.propertyIsEnumerable(cur)) return \"variableName\";\n    if (compareTypes.propertyIsEnumerable(cur)) return \"atom\";\n    if (status.propertyIsEnumerable(cur)) return \"comment\";\n    if (tags.propertyIsEnumerable(cur)) return \"typeName\";\n    if (storage.propertyIsEnumerable(cur)) return \"modifier\";\n    if (modifier.propertyIsEnumerable(cur)) return \"modifier\";\n    if (accessTypes.propertyIsEnumerable(cur)) return \"modifier\";\n    return \"variableName\";\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          var afterNext = stream.peek(); //look if the character if the quote is like the B in '10100010'B\n\n          if (afterNext) {\n            afterNext = afterNext.toLowerCase();\n            if (afterNext == \"b\" || afterNext == \"h\" || afterNext == \"o\") stream.next();\n          }\n\n          end = true;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n\n      if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    if (state.context && state.context.type == \"statement\") indent = state.context.indented;\n    return state.context = new Context(indent, col, type, null, state.context);\n  }\n\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  } //Interface\n\n\n  return {\n    startState: function startState() {\n      return {\n        tokenize: null,\n        context: new Context(-2, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n    },\n    token: function token(stream, state) {\n      var ctx = state.context;\n\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") {\n        popContext(state);\n      } else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") {\n          ctx = popContext(state);\n        }\n\n        if (ctx.type == \"}\") ctx = popContext(state);\n\n        while (ctx.type == \"statement\") {\n          ctx = popContext(state);\n        }\n      } else if (curPunc == ctx.type) popContext(state);else if (indentStatements && ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';' || ctx.type == \"statement\" && curPunc == \"newstatement\")) pushContext(state, stream.column(), \"statement\");\n\n      state.startOfLine = false;\n      return style;\n    },\n    languageData: {\n      indentOnInput: /^\\s*[{}]$/,\n      commentTokens: {\n        line: \"--\"\n      }\n    }\n  };\n}\n;"],"sourceRoot":""}