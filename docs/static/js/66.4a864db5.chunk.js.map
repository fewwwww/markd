{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/octave.js"],"names":["wordRegexp","words","RegExp","join","singleOperators","singleDelimiters","doubleOperators","doubleDelimiters","tripleDelimiters","expressionEnd","identifiers","builtins","keywords","tokenTranspose","stream","state","sol","peek","tokenize","tokenBase","next","tokenComment","match","skipToEnd","eatSpace","m","octave","startState","token","style","languageData","commentTokens","line"],"mappings":"qGAAA,SAASA,EAAWC,GAClB,OAAO,IAAIC,OAAO,MAAQD,EAAME,KAAK,OAAS,SADhD,8CAIA,IAAIC,EAAkB,IAAIF,OAAO,gCAC7BG,EAAmB,IAAIH,OAAO,0BAC9BI,EAAkB,IAAIJ,OAAO,6DAC7BK,EAAmB,IAAIL,OAAO,wDAC9BM,EAAmB,IAAIN,OAAO,kBAC9BO,EAAgB,IAAIP,OAAO,aAC3BQ,EAAc,IAAIR,OAAO,iDACzBS,EAAWX,EAAW,CAAC,QAAS,OAAQ,WAAY,MAAO,OAAQ,OAAQ,OAAQ,MAAO,OAAQ,MAAO,MAAO,OAAQ,MAAO,QAAS,MAAO,MAAO,OAAQ,MAAO,OAAQ,OAAQ,MAAO,UAAW,QAAS,QAAS,UAAW,SAAU,QAAS,OAAQ,OAAQ,MAAO,OAAQ,QAAS,OAAQ,QAAS,QAAS,MAAO,OAAQ,MAAO,MAAO,MAAO,MAAO,MAAO,OAAQ,OAAQ,QAAS,OAAQ,OAAQ,QAAS,WAAY,OAAQ,QAAS,SAAU,SAAU,SAAU,OAAQ,OAAQ,WAAY,OAAQ,UAAW,MAAO,OAAQ,WAAY,UAAW,QAAS,SAAU,SAAU,aAC1kBY,EAAWZ,EAAW,CAAC,SAAU,OAAQ,SAAU,OAAQ,SAAU,MAAO,QAAS,cAAe,KAAM,YAAa,KAAM,MAAO,QAAS,MAAO,QAAS,WAAY,aAAc,SAAU,UAAW,SAAU,aAAc,SAAU,WAAY,SAAU,UAAW,OAAQ,QAAS,WAAY,QAEhT,SAASa,EAAeC,EAAQC,GAC9B,OAAKD,EAAOE,OAA2B,MAAlBF,EAAOG,QAM5BF,EAAMG,SAAWC,EACVA,EAAUL,EAAQC,KANvBD,EAAOM,OACPL,EAAMG,SAAWC,EACV,YAOX,SAASE,EAAaP,EAAQC,GAC5B,OAAID,EAAOQ,MAAM,UACfP,EAAMG,SAAWC,EACV,YAITL,EAAOS,YACA,WAGT,SAASJ,EAAUL,EAAQC,GAEzB,GAAID,EAAOU,WAAY,OAAO,KAE9B,GAAIV,EAAOQ,MAAM,MAGf,OAFAP,EAAMG,SAAWG,EACjBP,EAAOS,YACA,UAGT,GAAIT,EAAOQ,MAAM,SAEf,OADAR,EAAOS,YACA,UAIT,GAAIT,EAAOQ,MAAM,cAAc,GAAQ,CACrC,GAAIR,EAAOQ,MAAM,6BAEf,OADAR,EAAOI,SAAWC,EACX,SAKT,GAAIL,EAAOQ,MAAM,wCACf,MAAO,SAKT,GAAIR,EAAOQ,MAAM,mCACf,MAAO,SAMX,GAAIR,EAAOQ,MAAMtB,EAAW,CAAC,MAAO,MAAO,MAAO,SAChD,MAAO,SAKT,IAAIyB,EAAIX,EAAOQ,MAAM,wBAA0BR,EAAOQ,MAAM,uBAE5D,OAAIG,EACKA,EAAE,GAAK,SAAW,QAIvBX,EAAOQ,MAAMV,GACR,UAKLE,EAAOQ,MAAMX,GACR,UAKLG,EAAOQ,MAAMZ,GACR,WAKLI,EAAOQ,MAAMlB,IAAoBU,EAAOQ,MAAMhB,GACzC,WAKLQ,EAAOQ,MAAMjB,IAAqBS,EAAOQ,MAAMf,IAAqBO,EAAOQ,MAAMd,GAC5E,KAKLM,EAAOQ,MAAMb,IACfM,EAAMG,SAAWL,EACV,OAKTC,EAAOM,OACA,SAIF,IAAIM,EAAS,CAClBC,WAAY,WACV,MAAO,CACLT,SAAUC,IAGdS,MAAO,SAAed,EAAQC,GAC5B,IAAIc,EAAQd,EAAMG,SAASJ,EAAQC,GAMnC,MAJc,WAAVc,GAAgC,aAAVA,IACxBd,EAAMG,SAAWL,GAGZgB,GAETC,aAAc,CACZC,cAAe,CACbC,KAAM","file":"static/js/66.4a864db5.chunk.js","sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/&|\\\\^~<>!@'\\\\\\\\]\");\nvar singleDelimiters = new RegExp('^[\\\\(\\\\[\\\\{\\\\},:=;\\\\.]');\nvar doubleOperators = new RegExp(\"^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\\\.[\\\\+\\\\-\\\\*/\\\\^\\\\\\\\]))\");\nvar doubleDelimiters = new RegExp(\"^((!=)|(\\\\+=)|(\\\\-=)|(\\\\*=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\nvar tripleDelimiters = new RegExp(\"^((>>=)|(<<=))\");\nvar expressionEnd = new RegExp(\"^[\\\\]\\\\)]\");\nvar identifiers = new RegExp(\"^[_A-Za-z\\xA1-\\uFFFF][_A-Za-z0-9\\xA1-\\uFFFF]*\");\nvar builtins = wordRegexp(['error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos', 'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones', 'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov', 'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot', 'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str', 'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember']);\nvar keywords = wordRegexp(['return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction', 'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events', 'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until', 'continue', 'pkg']); // tokenizers\n\nfunction tokenTranspose(stream, state) {\n  if (!stream.sol() && stream.peek() === '\\'') {\n    stream.next();\n    state.tokenize = tokenBase;\n    return 'operator';\n  }\n\n  state.tokenize = tokenBase;\n  return tokenBase(stream, state);\n}\n\nfunction tokenComment(stream, state) {\n  if (stream.match(/^.*%}/)) {\n    state.tokenize = tokenBase;\n    return 'comment';\n  }\n\n  ;\n  stream.skipToEnd();\n  return 'comment';\n}\n\nfunction tokenBase(stream, state) {\n  // whitespaces\n  if (stream.eatSpace()) return null; // Handle one line Comments\n\n  if (stream.match('%{')) {\n    state.tokenize = tokenComment;\n    stream.skipToEnd();\n    return 'comment';\n  }\n\n  if (stream.match(/^[%#]/)) {\n    stream.skipToEnd();\n    return 'comment';\n  } // Handle Number Literals\n\n\n  if (stream.match(/^[0-9\\.+-]/, false)) {\n    if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {\n      stream.tokenize = tokenBase;\n      return 'number';\n    }\n\n    ;\n\n    if (stream.match(/^[+-]?\\d*\\.\\d+([EeDd][+-]?\\d+)?[ij]?/)) {\n      return 'number';\n    }\n\n    ;\n\n    if (stream.match(/^[+-]?\\d+([EeDd][+-]?\\d+)?[ij]?/)) {\n      return 'number';\n    }\n\n    ;\n  }\n\n  if (stream.match(wordRegexp(['nan', 'NaN', 'inf', 'Inf']))) {\n    return 'number';\n  }\n\n  ; // Handle Strings\n\n  var m = stream.match(/^\"(?:[^\"]|\"\")*(\"|$)/) || stream.match(/^'(?:[^']|'')*('|$)/);\n\n  if (m) {\n    return m[1] ? 'string' : \"error\";\n  } // Handle words\n\n\n  if (stream.match(keywords)) {\n    return 'keyword';\n  }\n\n  ;\n\n  if (stream.match(builtins)) {\n    return 'builtin';\n  }\n\n  ;\n\n  if (stream.match(identifiers)) {\n    return 'variable';\n  }\n\n  ;\n\n  if (stream.match(singleOperators) || stream.match(doubleOperators)) {\n    return 'operator';\n  }\n\n  ;\n\n  if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) {\n    return null;\n  }\n\n  ;\n\n  if (stream.match(expressionEnd)) {\n    state.tokenize = tokenTranspose;\n    return null;\n  }\n\n  ; // Handle non-detected items\n\n  stream.next();\n  return 'error';\n}\n\n;\nexport var octave = {\n  startState: function startState() {\n    return {\n      tokenize: tokenBase\n    };\n  },\n  token: function token(stream, state) {\n    var style = state.tokenize(stream, state);\n\n    if (style === 'number' || style === 'variable') {\n      state.tokenize = tokenTranspose;\n    }\n\n    return style;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"%\"\n    }\n  }\n};"],"sourceRoot":""}