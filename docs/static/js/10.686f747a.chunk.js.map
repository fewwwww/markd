{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/verilog.js"],"names":["mkVerilog","parserConfig","statementIndentUnit","dontAlignCalls","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","curPunc","curKeyword","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","style","quote","ch","peek","test","next","eatWhile","tokenize","escaped","end","eat","tokenComment","skipToEnd","backUp","match","cur","current","maybeEnd","Context","indented","column","type","align","prev","this","pushContext","col","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","startState","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","close","indent","textAfter","cx","fromHook","firstChar","charAt","closing","possibleClosing","unit","languageData","indentOnInput","allClosings","closings","j","push","RegExp","join","buildElectricInputRegEx","commentTokens","line","block","open","verilog","tlvIdentifierStyle","\"","tlvScopePrefixChars","tlvIdentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlv","electricInput","tlvInBlockComment","string","tlvCodeActive","pos","depth","tlvIndentationStyle","blankline","chPos","bodyString","slice","pop","tlvNextIndent","prefix","mnemonic","hasOwnProperty","eol"],"mappings":"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","file":"static/js/10.686f747a.chunk.js","sourcesContent":["function mkVerilog(parserConfig) {\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {},\n        words = str.split(\" \");\n\n    for (var i = 0; i < words.length; ++i) {\n      obj[words[i]] = true;\n    }\n\n    return obj;\n  }\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n\n\n  var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n  var curPunc;\n  var curKeyword; // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n\n  var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\"); // Opening/closing pairs\n\n  var openClose = {};\n\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"] = \"while\";\n  openClose[\"fork\"] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  } // Keywords which open statements that are ended with a semi-colon\n\n\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(),\n        style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    } // Macros (tick-defines)\n\n\n    if (ch == '`') {\n      stream.next();\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    } // System calls\n\n\n    if (ch == '$') {\n      stream.next();\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    } // Time literals\n\n\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    } // Strings\n\n\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } // Comments\n\n\n    if (ch == \"/\") {\n      stream.next();\n\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      stream.backUp(1);\n    } // Numeric literals\n\n\n    if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n      return \"number\";\n    } // Operators\n\n\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    } // Keywords / plain variables\n\n\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n\n        curKeyword = cur;\n        return \"keyword\";\n      }\n\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n\n      if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false,\n        ch;\n\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n\n      maybeEnd = ch == \"*\";\n    }\n\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n\n  function popContext(state) {\n    var t = state.context.type;\n\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  } // Interface\n\n\n  return {\n    startState: function startState(indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n    token: function token(stream, state) {\n      var ctx = state.context;\n\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n\n        if (style !== undefined) {\n          return style;\n        }\n      }\n\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if (curPunc == \";\" && ctx.type == \"statement\" || ctx.type && isClosing(curKeyword, ctx.type)) {\n        ctx = popContext(state);\n\n        while (ctx && ctx.type == \"statement\") {\n          ctx = popContext(state);\n        }\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {// The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {// Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n    indent: function indent(state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n\n      var ctx = state.context,\n          firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {\n        line: \"//\",\n        block: {\n          open: \"/*\",\n          close: \"*/\"\n        }\n      }\n    }\n  };\n}\n\n;\nexport var verilog = mkVerilog({}); // TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\n\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",\n  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",\n  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n}; // Lines starting with these characters define scope (result in indentation).\n\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\n\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\nexport var tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function token(stream, state) {\n      var style = undefined;\n      var match; // Return value of pattern matches.\n      // Set highlighting mode based on code region (TLV or SV).\n\n      if (stream.sol() && !state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)) {\n            state.tlvCodeActive = true;\n          }\n        } // Correct indentation in the face of a line prefix char.\n\n\n        if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        } // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n\n\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n\n            if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit; // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n\n                if (tlvTrackStatements) {\n                  state.statementComment = false;\n                }\n\n                depth++;\n              }\n            }\n          } // Clear out deeper indentation levels unless line is blank.\n\n\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        } // Set next level of indentation.\n\n\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n        var beginStatement = false;\n\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement = stream.peek() != \" \" && // not a space\n          style === undefined && // not a region identifier\n          !state.tlvInBlockComment && // not in block comment\n          //!stream.match(tlvCommentMatch, false) && // not comment start\n          stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n\n            state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n\n        if (style !== undefined) {} else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n\n          if ( // is identifier prefix\n          tlvIdentifierStyle.hasOwnProperty(prefix) && ( // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n          mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = match[1] == \"+\" ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)) {\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n\n      return style;\n    },\n    indent: function indent(state) {\n      return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n    },\n    startState: function startState(state) {\n      state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n\n      state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n\n      state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n\n      state.tlvInBlockComment = false; // True inside /**/ comment.\n\n      if (tlvTrackStatements) {\n        state.statementComment = false; // True inside a statement's header comment.\n      }\n    }\n  }\n});"],"sourceRoot":""}