{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/lua.js"],"names":["wordRE","words","RegExp","join","builtins","keywords","indentTokens","dedentTokens","dedentPartial","readBracket","stream","level","eat","normal","state","quote","ch","next","cur","bracketed","skipToEnd","escaped","test","peek","eatWhile","style","curlev","lua","startState","basecol","indentDepth","token","eatSpace","word","current","indent","textAfter","cx","closing","unit","languageData","indentOnInput","commentTokens","line","block","open","close"],"mappings":"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","file":"static/js/58.bd365ccb.chunk.js","sourcesContent":["function prefixRE(words) {\n  return new RegExp(\"^(?:\" + words.join(\"|\") + \")\", \"i\");\n}\n\nfunction wordRE(words) {\n  return new RegExp(\"^(?:\" + words.join(\"|\") + \")$\", \"i\");\n} // long list of standard functions from lua manual\n\n\nvar builtins = wordRE([\"_G\", \"_VERSION\", \"assert\", \"collectgarbage\", \"dofile\", \"error\", \"getfenv\", \"getmetatable\", \"ipairs\", \"load\", \"loadfile\", \"loadstring\", \"module\", \"next\", \"pairs\", \"pcall\", \"print\", \"rawequal\", \"rawget\", \"rawset\", \"require\", \"select\", \"setfenv\", \"setmetatable\", \"tonumber\", \"tostring\", \"type\", \"unpack\", \"xpcall\", \"coroutine.create\", \"coroutine.resume\", \"coroutine.running\", \"coroutine.status\", \"coroutine.wrap\", \"coroutine.yield\", \"debug.debug\", \"debug.getfenv\", \"debug.gethook\", \"debug.getinfo\", \"debug.getlocal\", \"debug.getmetatable\", \"debug.getregistry\", \"debug.getupvalue\", \"debug.setfenv\", \"debug.sethook\", \"debug.setlocal\", \"debug.setmetatable\", \"debug.setupvalue\", \"debug.traceback\", \"close\", \"flush\", \"lines\", \"read\", \"seek\", \"setvbuf\", \"write\", \"io.close\", \"io.flush\", \"io.input\", \"io.lines\", \"io.open\", \"io.output\", \"io.popen\", \"io.read\", \"io.stderr\", \"io.stdin\", \"io.stdout\", \"io.tmpfile\", \"io.type\", \"io.write\", \"math.abs\", \"math.acos\", \"math.asin\", \"math.atan\", \"math.atan2\", \"math.ceil\", \"math.cos\", \"math.cosh\", \"math.deg\", \"math.exp\", \"math.floor\", \"math.fmod\", \"math.frexp\", \"math.huge\", \"math.ldexp\", \"math.log\", \"math.log10\", \"math.max\", \"math.min\", \"math.modf\", \"math.pi\", \"math.pow\", \"math.rad\", \"math.random\", \"math.randomseed\", \"math.sin\", \"math.sinh\", \"math.sqrt\", \"math.tan\", \"math.tanh\", \"os.clock\", \"os.date\", \"os.difftime\", \"os.execute\", \"os.exit\", \"os.getenv\", \"os.remove\", \"os.rename\", \"os.setlocale\", \"os.time\", \"os.tmpname\", \"package.cpath\", \"package.loaded\", \"package.loaders\", \"package.loadlib\", \"package.path\", \"package.preload\", \"package.seeall\", \"string.byte\", \"string.char\", \"string.dump\", \"string.find\", \"string.format\", \"string.gmatch\", \"string.gsub\", \"string.len\", \"string.lower\", \"string.match\", \"string.rep\", \"string.reverse\", \"string.sub\", \"string.upper\", \"table.concat\", \"table.insert\", \"table.maxn\", \"table.remove\", \"table.sort\"]);\nvar keywords = wordRE([\"and\", \"break\", \"elseif\", \"false\", \"nil\", \"not\", \"or\", \"return\", \"true\", \"function\", \"end\", \"if\", \"then\", \"else\", \"do\", \"while\", \"repeat\", \"until\", \"for\", \"in\", \"local\"]);\nvar indentTokens = wordRE([\"function\", \"if\", \"repeat\", \"do\", \"\\\\(\", \"{\"]);\nvar dedentTokens = wordRE([\"end\", \"until\", \"\\\\)\", \"}\"]);\nvar dedentPartial = prefixRE([\"end\", \"until\", \"\\\\)\", \"}\", \"else\", \"elseif\"]);\n\nfunction readBracket(stream) {\n  var level = 0;\n\n  while (stream.eat(\"=\")) {\n    ++level;\n  }\n\n  stream.eat(\"[\");\n  return level;\n}\n\nfunction normal(stream, state) {\n  var ch = stream.next();\n\n  if (ch == \"-\" && stream.eat(\"-\")) {\n    if (stream.eat(\"[\") && stream.eat(\"[\")) return (state.cur = bracketed(readBracket(stream), \"comment\"))(stream, state);\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch == \"\\\"\" || ch == \"'\") return (state.cur = string(ch))(stream, state);\n  if (ch == \"[\" && /[\\[=]/.test(stream.peek())) return (state.cur = bracketed(readBracket(stream), \"string\"))(stream, state);\n\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w.%]/);\n    return \"number\";\n  }\n\n  if (/[\\w_]/.test(ch)) {\n    stream.eatWhile(/[\\w\\\\\\-_.]/);\n    return \"variable\";\n  }\n\n  return null;\n}\n\nfunction bracketed(level, style) {\n  return function (stream, state) {\n    var curlev = null,\n        ch;\n\n    while ((ch = stream.next()) != null) {\n      if (curlev == null) {\n        if (ch == \"]\") curlev = 0;\n      } else if (ch == \"=\") ++curlev;else if (ch == \"]\" && curlev == level) {\n        state.cur = normal;\n        break;\n      } else curlev = null;\n    }\n\n    return style;\n  };\n}\n\nfunction string(quote) {\n  return function (stream, state) {\n    var escaped = false,\n        ch;\n\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) break;\n      escaped = !escaped && ch == \"\\\\\";\n    }\n\n    if (!escaped) state.cur = normal;\n    return \"string\";\n  };\n}\n\nexport var lua = {\n  startState: function startState(basecol) {\n    return {\n      basecol: basecol || 0,\n      indentDepth: 0,\n      cur: normal\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.cur(stream, state);\n    var word = stream.current();\n\n    if (style == \"variable\") {\n      if (keywords.test(word)) style = \"keyword\";else if (builtins.test(word)) style = \"builtin\";\n    }\n\n    if (style != \"comment\" && style != \"string\") {\n      if (indentTokens.test(word)) ++state.indentDepth;else if (dedentTokens.test(word)) --state.indentDepth;\n    }\n\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    var closing = dedentPartial.test(textAfter);\n    return state.basecol + cx.unit * (state.indentDepth - (closing ? 1 : 0));\n  },\n  languageData: {\n    indentOnInput: /^\\s*(?:end|until|else|\\)|\\})$/,\n    commentTokens: {\n      line: \"--\",\n      block: {\n        open: \"--[[\",\n        close: \"]]--\"\n      }\n    }\n  }\n};"],"sourceRoot":""}