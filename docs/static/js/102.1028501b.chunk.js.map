{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/webidl.js"],"names":["wordRegexp","words","RegExp","join","builtinArray","builtins","typeArray","types","keywordArray","keywords","atomArray","atoms","startDefs","endDefs","singleOperators","integers","floats","identifiers","identifiersEnd","strings","multilineComments","multilineCommentsStart","multilineCommentsEnd","webIDL","startState","inComment","lastToken","startDef","endDef","token","stream","state","style","eatSpace","match","skipToEnd","nextToken","next","readToken","cur","current","test","languageData","autocomplete","concat"],"mappings":"sGAAA,SAASA,EAAWC,GAClB,OAAO,IAAIC,OAAO,MAAQD,EAAME,KAAK,OAAS,SADhD,8CAKA,IAAIC,EAAe,CAAC,QAAS,cAAe,eAAgB,UAAW,eAAgB,SAAU,gBAAiB,mBAAoB,oCAAqC,cAAe,mBAAoB,YAAa,oBAAqB,mBAAoB,cAAe,cAAe,aAAc,uBAAwB,cAAe,cAAe,cAAe,eACjXC,EAAWL,EAAWI,GACtBE,EAAY,CAAC,WAAY,QAAS,OACtC,eAAgB,QAAS,SACzB,UAAW,OAAQ,QACnB,UACA,cAAe,WAAY,YAAa,aAAc,aAAc,aAAc,cAAe,cAAe,oBAAqB,eAAgB,eACrJ,aAAc,YAAa,YAAa,WAAY,SAAU,SAAU,QAAS,eAAgB,cACjG,MACA,QAEIC,EAAQP,EAAWM,GACnBE,EAAe,CAAC,YAAa,WAAY,QAAS,UAAW,aAAc,OAAQ,SAAU,aAAc,UAAW,YAAa,WAAY,eAAgB,UAAW,UAAW,WAAY,aAAc,UAAW,SAAU,SAAU,cAAe,UAEjQ,WAAY,WAAY,MACpBC,EAAWT,EAAWQ,GACtBE,EAAY,CAAC,OAAQ,QACzB,WAAY,MACZ,QAEIC,EAAQX,EAAWU,GAEnBE,EAAYZ,EADI,CAAC,WAAY,aAAc,OAAQ,cAGnDa,EAAUb,EADI,CAAC,YAEfc,EAAkB,WAClBC,EAAW,6CACXC,EAAS,+EACTC,EAAc,4BACdC,EAAiB,oCACjBC,EAAU,WACVC,EAAoB,eACpBC,EAAyB,UACzBC,EAAuB,WAqEpB,IAAIC,EAAS,CAClBC,WAAY,WACV,MAAO,CAELC,WAAW,EAEXC,UAAW,GAEXC,UAAU,EAEVC,QAAQ,IAGZC,MAAO,SAAeC,EAAQC,GAC5B,IAAIC,EAjFR,SAAmBF,EAAQC,GAEzB,GAAID,EAAOG,WAAY,OAAO,KAE9B,GAAIF,EAAMN,UACR,OAAIK,EAAOI,MAAMZ,IACfS,EAAMN,WAAY,EACX,YAGTK,EAAOK,YACA,WAGT,GAAIL,EAAOI,MAAM,MAEf,OADAJ,EAAOK,YACA,UAGT,GAAIL,EAAOI,MAAMd,GAAoB,MAAO,UAE5C,GAAIU,EAAOI,MAAMb,GAEf,OADAU,EAAMN,WAAY,EACX,UAIT,GAAIK,EAAOI,MAAM,cAAc,KACzBJ,EAAOI,MAAMnB,IAAae,EAAOI,MAAMlB,IAAS,MAAO,SAI7D,GAAIc,EAAOI,MAAMf,GAAU,MAAO,SAElC,GAAIY,EAAMJ,UAAYG,EAAOI,MAAMjB,GAAc,MAAO,MAExD,GAAIc,EAAMH,QAAUE,EAAOI,MAAMhB,GAE/B,OADAa,EAAMH,QAAS,EACR,MAGT,GAAIE,EAAOI,MAAMzB,GAAW,MAAO,UAEnC,GAAIqB,EAAOI,MAAM3B,GAAQ,CACvB,IAAImB,EAAYK,EAAML,UAClBU,GAAaN,EAAOI,MAAM,eAAe,IAAU,IAAI,GAE3D,MAAkB,MAAdR,GAAmC,eAAdA,GAA4C,eAAdU,GAA4C,MAAdA,EAE5E,UAGA,OAIX,OAAIN,EAAOI,MAAM7B,GAAkB,UAC/ByB,EAAOI,MAAMvB,GAAe,OAC5BmB,EAAOI,MAAMjB,GAAqB,WAElCa,EAAOI,MAAMpB,GAAyB,YAE1CgB,EAAOO,OACA,MAkBOC,CAAUR,EAAQC,GAE9B,GAAIC,EAAO,CACT,IAAIO,EAAMT,EAAOU,UACjBT,EAAML,UAAYa,EAEJ,YAAVP,GACFD,EAAMJ,SAAWf,EAAU6B,KAAKF,GAChCR,EAAMH,OAASG,EAAMH,QAAUf,EAAQ4B,KAAKF,IAE5CR,EAAMJ,UAAW,EAIrB,OAAOK,GAETU,aAAc,CACZC,aAAcvC,EAAawC,OAAOtC,GAAWsC,OAAOpC,GAAcoC,OAAOlC","file":"static/js/102.1028501b.chunk.js","sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\n;\nvar builtinArray = [\"Clamp\", \"Constructor\", \"EnforceRange\", \"Exposed\", \"ImplicitThis\", \"Global\", \"PrimaryGlobal\", \"LegacyArrayClass\", \"LegacyUnenumerableNamedProperties\", \"LenientThis\", \"NamedConstructor\", \"NewObject\", \"NoInterfaceObject\", \"OverrideBuiltins\", \"PutForwards\", \"Replaceable\", \"SameObject\", \"TreatNonObjectAsNull\", \"TreatNullAs\", \"EmptyString\", \"Unforgeable\", \"Unscopeable\"];\nvar builtins = wordRegexp(builtinArray);\nvar typeArray = [\"unsigned\", \"short\", \"long\", // UnsignedIntegerType\n\"unrestricted\", \"float\", \"double\", // UnrestrictedFloatType\n\"boolean\", \"byte\", \"octet\", // Rest of PrimitiveType\n\"Promise\", // PromiseType\n\"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\", \"Float32Array\", \"Float64Array\", // BufferRelatedType\n\"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\", \"Error\", \"DOMException\", \"FrozenArray\", // Rest of NonAnyType\n\"any\", // Rest of SingleType\n\"void\" // Rest of ReturnType\n];\nvar types = wordRegexp(typeArray);\nvar keywordArray = [\"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\", \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\", \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\", \"stringifier\", \"typedef\", // ArgumentNameKeyword except\n// \"unrestricted\"\n\"optional\", \"readonly\", \"or\"];\nvar keywords = wordRegexp(keywordArray);\nvar atomArray = [\"true\", \"false\", // BooleanLiteral\n\"Infinity\", \"NaN\", // FloatLiteral\n\"null\" // Rest of ConstValue\n];\nvar atoms = wordRegexp(atomArray);\nvar startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\nvar startDefs = wordRegexp(startDefArray);\nvar endDefArray = [\"typedef\"];\nvar endDefs = wordRegexp(endDefArray);\nvar singleOperators = /^[:<=>?]/;\nvar integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\nvar floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\nvar identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\nvar identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\nvar strings = /^\"[^\"]*\"/;\nvar multilineComments = /^\\/\\*.*?\\*\\//;\nvar multilineCommentsStart = /^\\/\\*.*/;\nvar multilineCommentsEnd = /^.*?\\*\\//;\n\nfunction readToken(stream, state) {\n  // whitespace\n  if (stream.eatSpace()) return null; // comment\n\n  if (state.inComment) {\n    if (stream.match(multilineCommentsEnd)) {\n      state.inComment = false;\n      return \"comment\";\n    }\n\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (stream.match(multilineComments)) return \"comment\";\n\n  if (stream.match(multilineCommentsStart)) {\n    state.inComment = true;\n    return \"comment\";\n  } // integer and float\n\n\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    if (stream.match(integers) || stream.match(floats)) return \"number\";\n  } // string\n\n\n  if (stream.match(strings)) return \"string\"; // identifier\n\n  if (state.startDef && stream.match(identifiers)) return \"def\";\n\n  if (state.endDef && stream.match(identifiersEnd)) {\n    state.endDef = false;\n    return \"def\";\n  }\n\n  if (stream.match(keywords)) return \"keyword\";\n\n  if (stream.match(types)) {\n    var lastToken = state.lastToken;\n    var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n\n    if (lastToken === \":\" || lastToken === \"implements\" || nextToken === \"implements\" || nextToken === \"=\") {\n      // Used as identifier\n      return \"builtin\";\n    } else {\n      // Used as type\n      return \"type\";\n    }\n  }\n\n  if (stream.match(builtins)) return \"builtin\";\n  if (stream.match(atoms)) return \"atom\";\n  if (stream.match(identifiers)) return \"variable\"; // other\n\n  if (stream.match(singleOperators)) return \"operator\"; // unrecognized\n\n  stream.next();\n  return null;\n}\n\n;\nexport var webIDL = {\n  startState: function startState() {\n    return {\n      // Is in multiline comment\n      inComment: false,\n      // Last non-whitespace, matched token\n      lastToken: \"\",\n      // Next token is a definition\n      startDef: false,\n      // Last token of the statement is a definition\n      endDef: false\n    };\n  },\n  token: function token(stream, state) {\n    var style = readToken(stream, state);\n\n    if (style) {\n      var cur = stream.current();\n      state.lastToken = cur;\n\n      if (style === \"keyword\") {\n        state.startDef = startDefs.test(cur);\n        state.endDef = state.endDef || endDefs.test(cur);\n      } else {\n        state.startDef = false;\n      }\n    }\n\n    return style;\n  },\n  languageData: {\n    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)\n  }\n};"],"sourceRoot":""}