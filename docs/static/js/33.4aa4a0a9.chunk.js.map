{"version":3,"sources":["../node_modules/@codemirror/legacy-modes/mode/crystal.js"],"names":["wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywords","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","eatSpace","matched","match","eat","pop","tokenFollowType","matching","tokenBase","lastToken","tokenMacro","peek","skipToEnd","current","test","blocks","indexOf","currentIndent","lastStyle","hasOwnProperty","tokenNest","tokenQuote","delim","style","embed","next","phrase","sol","escaped","tokenHereDoc","begin","started","length","nextStyle","ch","crystal","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"mappings":"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","file":"static/js/33.4aa4a0a9.chunk.js","sourcesContent":["function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent,\n  \"fun\": tokenFollowIdent,\n  \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType,\n  \"module\": tokenFollowType,\n  \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType,\n  \"enum\": tokenFollowType,\n  \"union\": tokenFollowType\n};\nvar matching = {\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"(\": \")\",\n  \"<\": \">\"\n};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  } // Macros\n\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  } // Comments\n\n\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  } // Variables and keywords\n\n\n  var matched;\n\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n    matched = stream.current();\n\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  } // Class variables and instance variables\n  // or attributes\n\n\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  } // Constants and types\n\n\n  if (stream.match(types)) {\n    return \"tag\";\n  } // Symbols or ':' operator\n\n\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n\n    stream.eat(\":\");\n    return \"operator\";\n  } // Strings\n\n\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  } // Strings or regexps or macro variables or '%' operator\n\n\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if (delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  } // Here Docs\n\n\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n  } // Characters\n\n\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  } // Numbers\n\n\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  } // Operators\n\n\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  } // Parens and braces\n\n\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  } // Escapes\n\n\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace();\n\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nexport var crystal = {\n  startState: function startState() {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n  token: function token(stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};"],"sourceRoot":""}